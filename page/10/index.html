<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="颜貌岁岁改，波澜誓不起。">
<meta property="og:type" content="website">
<meta property="og:title" content="颜文字">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="颜文字">
<meta property="og:description" content="颜貌岁岁改，波澜誓不起。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="颜文字">
<meta name="twitter:description" content="颜貌岁岁改，波澜誓不起。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/10/"/>

  <title> 颜文字 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">颜文字</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'iRPRT9JgJfvxEsHZRgKm','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/Quartz2d(绘图)/" itemprop="url">
                  Quartz2D(绘图)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/Quartz2d(绘图)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/Quartz2d(绘图)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、基本图形绘制"><a href="#一、基本图形绘制" class="headerlink" title="一、基本图形绘制"></a>一、基本图形绘制</h2><ul>
<li>线段（线宽、线段样式）</li>
<li>矩形（空心、实心、颜色）</li>
<li>三角形、四边形等形状</li>
<li>1、说明 - (void)drawRect:(CGRect)rect 什么时候调用、调用次数等<ul>
<li>当 view 第一次被显示的时候调用(调用一次)</li>
<li>或者是重绘事件被触发的时候</li>
<li>不要手动去调用这个方法</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>手动调用重绘方法 setNeedsDisplay 或者 setNeedsDisplayInRect:</strong></p>
<pre><code>setNeedsDisplay 方法会把之前的内容都清除掉, 然后再重绘。
setNeedsDisplayInRect:&lt;#(CGRect)#&gt;局部刷新
</code></pre></li>
</ul>
<ul>
<li>2、说明为什么要在 - (void)drawRect:(CGRect)rect 方法中进行绘图</li>
<li><strong>只有在这个方法中才能获取当前 View 的绘图上下文</strong></li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>当要向UIView上绘图的时候, 必须重写UIView的drawRect:方法, 然后在这个方法中进行绘图</li>
<li>在drawRect:方法中获取的参数rect, 指的就是当前view的bounds属性</li>
<li>为什么向当前view中绘制图形, 必须在drawRect:方法中进行?<ul>
<li>3.1 原因: 只有在当前view的drawRect:方法中才能成功的获取当前view的”图形上下文”, 有了图形上下文才能进行绘图</li>
<li>3.2 为什么只有在drawRect:方法中才能获取当前view的图形上下文呢？</li>
<li>3.3 原因: 是因为系统在调用drawRect:方法之前已经帮我们创建好了一个与当前view相关的图形上下文了, 然后才调用的drawRect:方法, 所以在drawRect:方法中, 我们就可以成功获取当前view的图形上下文了。</li>
<li>3.4 如何创建一个图形上下文？（后面说）<ul>
<li>3.5 drawRect:方法是谁来调用的？什么时候调用的？<ul>
<li>3.5.1 drawRect:方法是系统帮我们调用的, 千万别手动去调用这个方法。原因是, 自己手动去调用drawRect:方法的时候无法保证系统已经帮我们创建好了”图形上下文”, 所以这样就无法保证在drawRect:方法中获取”图形上下文”对象, 所以也就无法绘图。</li>
<li>3.5.2 drawRect:方法的什么时候被调用？<ul>
<li>1&gt; 当这个View第一次显示的时候会条用一次drawRect:方法。</li>
<li>2&gt; 当这个View执行重绘操作的时候, 会重新调用drawRect:方法来进行绘图。</li>
<li>3&gt; 通过调用【[self setNeedsDisplay];// 把这个view都重绘一次】 或 【[self setNeedsDisplayInRect:(CGRect)]// 把view中的某个区域重绘一次】 来实现重绘</li>
<li>4&gt; 在每次调用 setNeedsDisplay 或 setNeedsDisplayInRect:方法的时候, 内部会先创建一个与当前view相关连的”图形上下文”然后再调用drawRect:实现重绘。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意: UIBezierPath 对象可以独立使用,  无需手动获取“图形上下文”对象，此处为了更好的理解“图形上下文对象”所以暂时还是采用手动获取“图形上下文”对象的方式来绘图
</strong>        </p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h6 id="1、绘制一个”三角形”"><a href="#1、绘制一个”三角形”" class="headerlink" title="1、绘制一个”三角形”"></a>1、绘制一个”三角形”</h6><pre><code>// 1. 获取当前的图形上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 2. 在上下文中绘制图形（拼接路径）
// 2.1 设置一个起点
CGContextMoveToPoint(ctx, 20, 20);
// 2.2 添加一条直线到(100, 100)这个点
CGContextAddLineToPoint(ctx, 100, 100);
// 2.3 再添加一条线
CGContextAddLineToPoint(ctx, 120, 30);
// 2.4 再添加一条线段
//CGContextAddLineToPoint(ctx, 20, 20);
// 另外一种做法: 直接关闭路径（连接最后一个点和起点）
CGContextClosePath(ctx);
// 3. 把上下文渲染显示到 HMView01上
// StrokePath 表示把路径以空心的形式渲染出来。
CGContextStrokePath(ctx);
</code></pre><h6 id="2、绘制一个实心”矩形”"><a href="#2、绘制一个实心”矩形”" class="headerlink" title="2、绘制一个实心”矩形”"></a>2、绘制一个实心”矩形”</h6><pre><code>// 绘制一个&quot;四边形&quot;
// 1. 获取当前图形上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 2. 开始绘制路径
CGContextAddRect(ctx, CGRectMake(20, 20, 100, 120));
// 3. 渲染
CGContextFillPath(ctx);
</code></pre><h6 id="3、设置图形的颜色"><a href="#3、设置图形的颜色" class="headerlink" title="3、设置图形的颜色"></a>3、设置图形的颜色</h6><pre><code>// 绘制一个&quot;四边形&quot;
// 1. 获取当前图形上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 2. 开始绘制路径
CGContextAddRect(ctx, CGRectMake(20, 20, 100, 120));

//============ C 语言的方式设置颜色 =================
CGContextSetRGBFillColor(ctx, 200/255.0, 100/255.0, 50/255.0, 1.0);
//CGContextSetRGBStrokeColor(&lt;#CGContextRef context#&gt;, &lt;#CGFloat red#&gt;, &lt;#CGFloat green#&gt;, &lt;#CGFloat blue#&gt;, &lt;#CGFloat alpha#&gt;)
//============ C 语言的方式设置颜色 =================

//============ OC 的方式设置颜色 =================
// 设置空心图形的线条颜色
// [[UIColor redColor] setStroke];
// 设置实心图形的填充颜色
// [[UIColor redColor] setFill];
// 统一设置&quot;空心图形&quot; 和 &quot;实心图形&quot;的颜色
//[[UIColor redColor] set];
//============ OC 的方式设置颜色 =================
// 3. 渲染
CGContextFillPath(ctx);
</code></pre><h6 id="4、设置不同线段-不同颜色"><a href="#4、设置不同线段-不同颜色" class="headerlink" title="4、设置不同线段, 不同颜色"></a>4、设置不同线段, 不同颜色</h6><pre><code>//画两根线, 一根红色, 一根蓝色
// 1. 获取上下文对象
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 2. 绘制图形
// 2.1 设置起点
CGContextMoveToPoint(ctx, 50, 50);
// 2.2 添加一根线
CGContextAddLineToPoint(ctx, 50, 150);
// 2.3 设置线段颜色
[[UIColor redColor] set];
// 2.4 设置线宽
CGContextSetLineWidth(ctx, 10);
// 渲染一次
CGContextStrokePath(ctx);

// 再移动到一个新的起点
CGContextMoveToPoint(ctx, 100, 50);
// 再添加一根线
CGContextAddLineToPoint(ctx, 100, 150);
// 设置线的颜色
[[UIColor blueColor] set];
// 3. 渲染&quot;上下文对象&quot;到 view 上
CGContextStrokePath(ctx);
</code></pre><h6 id="5、设置线段”头尾部”的样式"><a href="#5、设置线段”头尾部”的样式" class="headerlink" title="5、设置线段”头尾部”的样式"></a>5、设置线段”头尾部”的样式</h6><pre><code> // 1. 获取上下文对象
 CGContextRef ctx = UIGraphicsGetCurrentContext();
 // 2. 绘制路径
 // 2.1 移动到起点
 CGContextMoveToPoint(ctx, 20, 20);
 // 2.2 添加一条线段
 CGContextAddLineToPoint(ctx, 100, 100);
 // 2.3 设置颜色
 [[UIColor redColor] set];
 // 2.4 设置线段宽度
 CGContextSetLineWidth(ctx, 15);
 // 2.5 设置线段头尾部样式
 //enum CGLineCap {
 //kCGLineCapButt, 默认值
 //kCGLineCapRound, 圆角
 //kCGLineCapSquare 方角
 //};
CGContextSetLineCap(ctx, kCGLineCapSquare);
// 3. 渲染
CGContextStrokePath(ctx);
</code></pre><h6 id="6、设置转折点样式"><a href="#6、设置转折点样式" class="headerlink" title="6、设置转折点样式"></a>6、设置转折点样式</h6><pre><code>// 2.4 设置线段宽度
CGContextSetLineWidth(ctx, 15);
// 2.5 设置线段头尾部样式
CGContextSetLineCap(ctx, kCGLineCapRound);
// 2.6 设置转折点样式
CGContextSetLineJoin(ctx, kCGLineJoinBevel);
</code></pre><h6 id="7、文字绘制-通过OC-来绘制图形"><a href="#7、文字绘制-通过OC-来绘制图形" class="headerlink" title="7、文字绘制(通过OC 来绘制图形)"></a>7、文字绘制(通过OC 来绘制图形)</h6><p><strong>1、绘制一段文字(思路: 直接使用 OC 的方法, 无需手动获取上下文对象)</strong></p>
<pre><code>NSString *str = @&quot;哈哈, 黑马程序员 iOS学院。&quot;;
NSDictionary *attrs = @{
    NSForegroundColorAttributeName : [UIColor redColor],
    NSFontAttributeName : [UIFont systemFontOfSize:20]
};
[str drawAtPoint:CGPointMake(30, 50) withAttributes:attrs];
</code></pre><p><strong>2、绘制一段文字到一个指定的区域</strong></p>
<p>思路: 调用字符串的 drawInRect: 方法.</p>
<pre><code>// 1. 绘制文字
NSString *str = @&quot;哈哈, 黑马程序员 iOS。&quot;;
NSDictionary *attrs = @{
NSForegroundColorAttributeName : [UIColor redColor],
NSFontAttributeName : [UIFont systemFontOfSize:20]
};

[str drawInRect:CGRectMake(20, 20, 50, 250) withAttributes:attrs];
// 1. 获取上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 2. 把矩形画出来
CGContextAddRect(ctx,CGRectMake(20, 20, 50, 250));
// 3. 渲染
CGContextStrokePath(ctx);
</code></pre><h6 id="8、图片绘制-通过OC-来绘制图形"><a href="#8、图片绘制-通过OC-来绘制图形" class="headerlink" title="8、图片绘制(通过OC 来绘制图形)"></a>8、图片绘制(通过OC 来绘制图形)</h6><p><strong>1、绘制一张图片到 UIView 上</strong></p>
<pre><code>// 1. 获取图片
UIImage *img = [UIImage imageNamed:@&quot;dst2&quot;];
// 2. 把图片画到当前的 view中
[img drawAtPoint:CGPointMake(0, 0)];
</code></pre><p><strong>2、在指定的矩形中绘制图片（会自动拉伸）</strong></p>
<pre><code>// 1. 获取图片
UIImage *img = [UIImage imageNamed:@&quot;dst2&quot;];
// 2. 把图片画到当前的 view中
[img drawInRect:CGRectMake(0, 0, 150, 150)];
</code></pre><p><strong>3、画格子花纹效果(（pattern）), 思路: 调用drawAsPatternInRect:方法</strong></p>
<pre><code>// 1. 获取图片
UIImage *img = [UIImage imageNamed:@&quot;abc&quot;];
// 2. 把图片画到当前的 view中
[img drawAsPatternInRect:self.bounds];
// 3. 在右下角显示文字
NSString *str = @&quot;@Lonely ios&quot;;
NSDictionary *attrs = @{
NSForegroundColorAttributeName : [UIColor redColor],
NSFontAttributeName : [UIFont systemFontOfSize:20]
};
[ str drawInRect:CGRectMake(0, 100, 200, 30) withAttributes:attrs];
</code></pre><h2 id="二、图形上下文栈"><a href="#二、图形上下文栈" class="headerlink" title="二、图形上下文栈"></a>二、图形上下文栈</h2><ul>
<li><strong>CGContextSaveGState(ctx);// 保存ctx这个绘图上下文对象</strong></li>
<li><strong>CGContextRestoreGState(ctx); // 恢复 ctx这个图形上下文</strong></li>
</ul>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><h6 id="1、矩阵操作"><a href="#1、矩阵操作" class="headerlink" title="1、矩阵操作"></a>1、矩阵操作</h6><pre><code>// 1. 获取上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 保存上下文
CGContextSaveGState(ctx);
//======================= 矩阵操作 ============================
// 1.1 旋转
CGContextRotateCTM(ctx, M_PI_4 * 0.5);
// 1.2 缩放
CGContextScaleCTM(ctx, 0.5, 0.5);
//======================= 矩阵操作 ============================
// 2. 绘制一些图形
CGContextMoveToPoint(ctx, 10, 10);
CGContextAddLineToPoint(ctx, 100, 100);
CGContextAddEllipseInRect(ctx, CGRectMake(130, 150, 100, 100));
// 恢复上下文
CGContextRestoreGState(ctx);
CGContextAddRect(ctx, CGRectMake(70, 90, 100, 80));
// 3. 渲染
CGContextStrokePath(ctx);
</code></pre><p><strong>注：在绘制任何图形前保存上下文, 在绘制最后一个图形前恢复上下文</strong></p>
<h6 id="2、图片裁剪"><a href="#2、图片裁剪" class="headerlink" title="2、图片裁剪"></a>2、图片裁剪</h6><pre><code>CGContextRef ctx = UIGraphicsGetCurrentContext();
// 1. 画圆，这里最好使用 Ellipse 来绘制圆（画圆和画图片都从0,0点开始）。
CGContextAddArc(ctx, 100, 100, 90, 0, M_PI * 2, 1);
// 2. 裁剪上下文, 注意裁剪完毕就只能在裁剪好的区域内画东西了, 超出的地方无法绘制图形。
CGContextClip(ctx);
// 3. 把图片绘制上去
UIImage *img = [UIImage imageNamed:@&quot;dst2&quot;];
[img drawAtPoint:CGPointMake(0, 0)];
</code></pre><h6 id="3、图片裁剪（返回圆形边框View）"><a href="#3、图片裁剪（返回圆形边框View）" class="headerlink" title="3、图片裁剪（返回圆形边框View）"></a>3、图片裁剪（返回圆形边框View）</h6><pre><code>- (UIImage *)zc_circleImage
{
    //NO -&gt; 透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    //获取上下文
    CGContextRef contex = UIGraphicsGetCurrentContext();
    //添加圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(contex, rect);
    //裁剪
    CGContextClip(contex);
    //将图片画上去
    [self drawInRect:rect];
    //获取图片
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    //关闭
    UIGraphicsEndImageContext();
    return image;
}
</code></pre><p><strong> 因为绘图操作是 CPU密集型操作（会大量使用到 CPU），所以如果可以使用普通 UIView 来代替的就不要自己进行绘图</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/数据存储(数据持久化)/" itemprop="url">
                  数据存储(数据持久化)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/数据存储(数据持久化)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/数据存储(数据持久化)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、iOS应用数据存储的常用方式"><a href="#一、iOS应用数据存储的常用方式" class="headerlink" title="一、iOS应用数据存储的常用方式"></a>一、iOS应用数据存储的常用方式</h2><ul>
<li>XML属性列表（plist）归档</li>
<li><p>Preference(偏好设置)</p>
<p>  <code>本质还是通过“plist”来存储数据, 但是使用更简单(无需关注文件、文件夹路径和名称)</code>    </p>
</li>
<li><p>NSKeyedArchiver归档(NSCoding)</p>
<p>  <code>把任何对象, 直接保存为文件的方式。</code></p>
</li>
<li><p>SQLite3 </p>
<p>  <code>当非常大量的数据存储时使用</code></p>
</li>
<li><p>Core Data</p>
<p>  <code>就是对SQLite的封装</code></p>
</li>
</ul>
<h2 id="二、应用沙盒"><a href="#二、应用沙盒" class="headerlink" title="二、应用沙盒"></a>二、应用沙盒</h2><h4 id="1、应用沙盒结构分析"><a href="#1、应用沙盒结构分析" class="headerlink" title="1、应用沙盒结构分析"></a>1、应用沙盒结构分析</h4><ul>
<li>应用程序包：(上图中的Layer)包含了所有的资源文件和可执行文件</li>
<li><p>Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录。保存相对重要的数据。</p>
</li>
<li><p>tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。保存不重要的并且大的数据。</p>
</li>
<li><p>Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据</p>
</li>
<li><p>Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录。该目录由系统管理, 无需我们来管理。通常用来存储一些基本的软件配置信息, 比如记住密码、自动登录等。</p>
</li>
</ul>
<p><strong>总结: 我们平时操作数据主要使用Documents目录。</strong></p>
<h4 id="2、应用沙盒目录的常见获取方式"><a href="#2、应用沙盒目录的常见获取方式" class="headerlink" title="2、应用沙盒目录的常见获取方式"></a>2、应用沙盒目录的常见获取方式</h4><h6 id="1、沙盒根目录：NSString-home-NSHomeDirectory"><a href="#1、沙盒根目录：NSString-home-NSHomeDirectory" class="headerlink" title="1、沙盒根目录：NSString *home = NSHomeDirectory();"></a>1、沙盒根目录：NSString *home = NSHomeDirectory();</h6><ul>
<li>Documents：(2种方式)</li>
<li><p>利用沙盒根目录拼接”Documents”字符串</p>
<pre><code>NSString *home = NSHomeDirectory();
NSString *documents = [home stringByAppendingPathComponent:@&quot;Documents&quot;];
</code></pre><p>  <strong>不建议采用，因为新版本的操作系统可能会修改目录名</strong></p>
</li>
</ul>
<h6 id="2、利用NSSearchPathForDirectoriesInDomains函数"><a href="#2、利用NSSearchPathForDirectoriesInDomains函数" class="headerlink" title="2、利用NSSearchPathForDirectoriesInDomains函数"></a>2、利用NSSearchPathForDirectoriesInDomains函数</h6><ul>
<li>NSUserDomainMask 代表从用户文件夹下找</li>
<li><p>YES 代表展开路径中的波浪字符“~”</p>
<pre><code>NSArray *array =  NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
</code></pre></li>
<li><p>在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素</p>
<pre><code>NSString *documents = [array objectAtIndex:0];
</code></pre></li>
</ul>
<h6 id="3、Tmp、Library-Caches、Library-Preference"><a href="#3、Tmp、Library-Caches、Library-Preference" class="headerlink" title="3、Tmp、Library/Caches、Library/Preference"></a>3、Tmp、Library/Caches、Library/Preference</h6><ul>
<li>tmp：NSString *tmp = NSTemporaryDirectory();</li>
<li>Library/Caches：(跟Documents类似的2种方法)<ul>
<li>利用沙盒根目录拼接”Caches”字符串</li>
<li>利用NSSearchPathForDirectoriesInDomains函数(将函数的第2个参数改为：NSCachesDirectory即可)</li>
</ul>
</li>
<li>Library/Preference：通过NSUserDefaults类存取该目录下的设置信息</li>
</ul>
<h2 id="三、属性列表（plist）"><a href="#三、属性列表（plist）" class="headerlink" title="三、属性列表（plist）"></a>三、属性列表（plist）</h2><ul>
<li>属性列表是一种XML格式的文件，拓展名为plist</li>
<li>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中</li>
</ul>
<h4 id="1、属性列表-归档NSDictionary"><a href="#1、属性列表-归档NSDictionary" class="headerlink" title="1、属性列表-归档NSDictionary"></a>1、属性列表-归档NSDictionary</h4><h6 id="将一个NSDictionary对象归档到一个plist属性列表中"><a href="#将一个NSDictionary对象归档到一个plist属性列表中" class="headerlink" title="将一个NSDictionary对象归档到一个plist属性列表中"></a>将一个NSDictionary对象归档到一个plist属性列表中</h6><ul>
<li><p>将数据封装成字典</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class="line">[dict setObject:@&quot;母鸡&quot; forKey:@&quot;name&quot;];</div><div class="line">[dict setObject:@&quot;15013141314&quot; forKey:@&quot;phone&quot;];</div><div class="line">[dict setObject:@&quot;27&quot; forKey:@&quot;age&quot;];</div></pre></td></tr></table></figure>
</li>
<li><p>将字典持久化到Documents/stu.plist文件中</p>
<pre><code>[dict writeToFile:path atomically:YES];
</code></pre><h4 id="2、属性列表-恢复NSDictionary"><a href="#2、属性列表-恢复NSDictionary" class="headerlink" title="2、属性列表-恢复NSDictionary"></a>2、属性列表-恢复NSDictionary</h4></li>
<li>读取属性列表，恢复NSDictionary对象</li>
<li><p>读取Documents/stu.plist的内容，实例化NSDictionary</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];</div><div class="line">NSLog(@&quot;name:%@&quot;, [dict objectForKey:@&quot;name&quot;]);</div><div class="line">NSLog(@&quot;phone:%@&quot;, [dict objectForKey:@&quot;phone&quot;]);</div><div class="line">NSLog(@&quot;age:%@&quot;, [dict objectForKey:@&quot;age&quot;]);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、偏好设置"><a href="#四、偏好设置" class="headerlink" title="四、偏好设置"></a>四、偏好设置</h2><ul>
<li><p>读取上次保存的设置</p>
<pre><code>NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSString *username = [defaults stringForKey:@&quot;username&quot;];
float textSize = [defaults floatForKey:@&quot;text_size&quot;];
BOOL autoLogin = [defaults boolForKey:@&quot;auto_login&quot;];
</code></pre></li>
</ul>
<p><strong>注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入</strong><br>[defaults synchornize];</p>
<h2 id="五、归档"><a href="#五、归档" class="headerlink" title="五、归档"></a>五、归档</h2><h4 id="对象必须遵守NSCoding协议"><a href="#对象必须遵守NSCoding协议" class="headerlink" title="对象必须遵守NSCoding协议"></a>对象必须遵守NSCoding协议</h4><ul>
<li>通过”plist”文件来保存数据, 无法直接将一个对象保存到文件中。比如Person对象就没有writeToFile方法。</li>
<li>“归档”是一种可以把任何对象, 直接保存为文件的方式。(其中包括”归档”与”反归档（读档）”)</li>
<li><p>归档: 对象 -&gt; 文件</p>
<pre><code>[NSKeyedArchiver archiveRootObject:person toFile:filePath];
</code></pre></li>
<li><p>反归档(读档): 文件 -&gt; 对象</p>
<pre><code>[NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
</code></pre></li>
<li>通过”归档”的方式能将任何遵守了NSCoding协议的”对象”存储到文件中</li>
<li><p>NSCoding协议的两个重要的方法:</p>
<ul>
<li><p>1、- (void)encodeWithCoder:(NSCoder *)aCoder;</p>
<pre><code>示例代码:
// 归档时调用该方法
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];
    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];
    [aCoder encodeDouble:self.height forKey:@&quot;height&quot;];
}

// 通过调用NSKeyedArchiver的archiveRootObject方法来实现归档
CZPerson *person = [[SteveZPerson alloc] init];
person.name = @&quot;JackMeng&quot;;
person.age = 27;
person.height = 1.75;

// 获取沙盒路径
NSString *sandBoxPath = NSHomeDirectory();
// 获取Documents的路径
NSString *docPath = [sandBoxPath stringByAppendingPathComponent:@&quot;Documents&quot;];
// 获取文件路径
NSString *filePath = [docPath stringByAppendingPathComponent:@&quot;person.plist&quot;];

// 将对象person归档
[NSKeyedArchiver archiveRootObject:person toFile:filePath];
</code></pre></li>
<li><p>2、 - (id)initWithCoder:(NSCoder *)aDecoder;</p>
<pre><code>// 读档时调用该方法
 - (id)initWithCoder:(NSCoder *)aDecoder
 {
     if (self = [super init]) {
     self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
     self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];
     self.height = [aDecoder decodeDoubleForKey:@&quot;height&quot;];
 }
    return self;
 }

 // 获取沙盒路径
 NSString *sandBoxPath = NSHomeDirectory();
 // 获取Documents的路径
 NSString *docPath = [sandBoxPath stringByAppendingPathComponent:@&quot;Documents&quot;];
 // 获取文件路径
 NSString *filePath = [docPath stringByAppendingPathComponent:@&quot;person.bin&quot;];

 CZPerson *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];

 NSLog(@&quot;name: %@, age: %ld, height: %f&quot;, person.name, person.age, person.height);
</code></pre><p><strong>如果父类中也有属性需要归档、读档, 在子类中必须调用super的相关方法</strong></p>
<p>  如果父类也遵守了NSCoding协议，请注意：<br>  应该在encodeWithCoder:方法中加上一句<br>  [super encodeWithCode:encode];<br>  确保继承的实例变量也能被编码，即也能被归档<br>  应该在initWithCoder:方法中加上一句<br>  self = [super initWithCoder:decoder];<br>  确保继承的实例变量也能被解码，即也能被恢复</p>
<h4 id="归档小节"><a href="#归档小节" class="headerlink" title="归档小节"></a>归档小节</h4></li>
</ul>
</li>
<li>自定义对象归档(归档：数据存储)<ul>
<li>1、自定义对象如何归档：用NSKeyedArchiver,调用archiveRootObject:toFile:方法，需要传一个对象，自定义一个对象，传进去。<ul>
<li>会报错,说对象没有encodeWithCoder方法，说明归档的时候默认会调用这个方法，去实现这个方法。</li>
<li>默认打不出encodeWithCoder，必须遵守NSCoding协议才能实现这个方法。</li>
<li>encodeWithCoder什么时候调用：对象归档时候调用</li>
<li>encodeWithCoder作用：告诉系统对象里的哪些属性需要归档，怎么去归档，根据一个key去归档，目的就是以后取的时候，也根据这个key去取数据。</li>
</ul>
</li>
<li>2、自定义对象如何解档:用NSKeyedUnarchiver,调用unarchiveObjectWithFile方法，需要传一个文件名。<ul>
<li>会报错,说对象没有initWithCoder方法，说明解档的时候默认会调用这个方法，去实现这个方法。</li>
<li>initWithCoder什么时候调用：对象解档时候调用</li>
<li>initWithCoder作用：告诉系统对象里的哪些属性需要解档，怎么去解档，根据之前存储的key去解档</li>
<li>initWithCoder是一个初始化方法，需要先初始化父类的，但是不能调用[super initWithCoder:],因为父类NSObject没有遵守NSCoding协议。</li>
</ul>
</li>
<li>3、initWithCoder什么时候需要调用[super initWithCoder:]<ul>
<li>initWithCoder原理:只要解析文件就会调用，xib,storyboard都是文件，因此只要解析这两个文件，就会调用initWithCoder。</li>
<li><strong>因此如果在storyboard使用自定义view,重写initWithCoder方法，一定要调用[super initWithCoder:]，因为只有系统才知道怎么解析storyboard，如果没有调用，就解析不了这个文件</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/项目文件介绍/" itemprop="url">
                  项目文件介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/项目文件介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/项目文件介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、项目文件介绍"><a href="#1、项目文件介绍" class="headerlink" title="1、项目文件介绍"></a>1、项目文件介绍</h2><ul>
<li>新建一个项目，最左侧中包含3个文件夹<ul>
<li>第1个文件夹包含项目相关的所有的代码文件及数据文件</li>
<li>supportingFiles里面包含配置文件及其他的数据文件</li>
<li>最后的UI-TESTS文件夹主要是做单元测试使用的，我们目前不会用到，所以先不考虑。</li>
</ul>
</li>
<li>info.plist文件，项目的配置信息文件</li>
<li>pch文件，项目中所有公用的类或者宏的头文件<h2 id="2、info-plist文件"><a href="#2、info-plist文件" class="headerlink" title="2、info.plist文件"></a>2、info.plist文件</h2></li>
<li>在Xcode6以前创建项目的时候为有一个“项目名称-info.plist”名称的文件，在Xcode6之后就直接就是info.plist文件了。</li>
<li>这个文件主要用来保存当前项目的基本配置信息<ul>
<li>info.plist文件内容实际上是xml格式的，通过 <strong>右键</strong> –&gt; <strong>open as sourceCode</strong> 可以看到。</li>
<li>保存的信息如应用版本号，应用要求的可运行的最低系统版本号。</li>
<li>应用程序启动要加载storyboard文件名称</li>
</ul>
</li>
<li>常用的key：<ul>
<li>bundle display name 应用名称的key，名称如果太长就不能完全显示了。</li>
<li>bundle identifier 应用的唯一标示，如果相同就会被覆盖。</li>
<li>bundle versions String short 最终应用发布时的版本号</li>
<li>bundle version 针对内部的一个版本号。</li>
<li>Supported interface ortations 标识设备所支持的方向，对应的选中”项目”-&gt;”General”-&gt;”Deployment Info”-&gt;”Device Orientation”。iPhone只支持3种方向，不支持上下颠倒的旋转，Portrait（竖屏），Landscape Left（横屏向左），Landscape Right（横屏向右）</li>
</ul>
</li>
</ul>
<h6 id="注意：自己创建的plist文件中不要包含Info关键字。"><a href="#注意：自己创建的plist文件中不要包含Info关键字。" class="headerlink" title="注意：自己创建的plist文件中不要包含Info关键字。"></a>注意：自己创建的plist文件中不要包含Info关键字。</h6><h2 id="3、pch文件"><a href="#3、pch文件" class="headerlink" title="3、pch文件"></a>3、pch文件</h2><ul>
<li>全称“Prefix Header File（前缀头文件）”，预编译头文件。</li>
<li><p>在Xcode 6以后苹果就不推荐使用了。</p>
<ul>
<li>遇到的问题：<ul>
<li>整个项目中很多地方都在使用某个类的头文件</li>
<li>整个项目中很多地方都在使用同一个”宏”</li>
<li>在项目中很多地方都用到了NSLog（）方法，想一下子全部清除掉</li>
</ul>
</li>
<li><p>解决以上问题，可以通过使用PCH文件，它也是个头文件类似于*.h文件</p>
<p><strong> 注意：PCH文件的特点，项目中所有其他代码文件无序显示导入该PCH文件，默认就可以访问（其他文件无序手动#import该PCH文件就能使用）</strong></p>
</li>
</ul>
</li>
<li><p>主要作用：</p>
<ul>
<li>可以做一些公用的宏定义</li>
<li>把公共的Model类的#import导入写到pch文件.</li>
<li>自定义NSLog()。例如:#define CZLog(…) NSLog(<strong>VA_ARGS</strong>)</li>
<li>创建pch文件<ul>
<li>“newFile”-&gt;””-&gt;””</li>
<li>将通用的头文件和相应的宏放进去。</li>
</ul>
</li>
<li><p>配置头文件，以使用头文件</p>
<ul>
<li>选择”项目”-&gt;”Build Setting” -&gt;”All”-&gt;搜索 “Prefix Header”,配置相应的pch文件。</li>
<li>“$(SRCROOT)/$(PRODUCT_NAME)/PrefixHeader.pch”（如果有问题，更换为下面的方式，可能会与中文有关）</li>
<li>“$(SRCROOT)/对应的文件夹名/PrefixHeader.pch”</li>
</ul>
</li>
<li><p>在应用程序测试的时候，需要log很多信息，但是如果我们发布程序的时候就要禁止打印信息。</p>
<ul>
<li>自定义自己的log方式。</li>
<li>自定义log的完整形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ifdef DEBUG</div><div class="line"></div><div class="line">#define CZLog(...) NSLog(__VA_ARGS__)</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">#define CZLog(...)</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在使用pch文件时的注意点：</p>
<ul>
<li>创建c语言文件进去，直接编译就报错，因为默认情况下所有文件都会包含pch文件中的OC内容，C语言文件内不能识别OC代码，所以就会报错。</li>
<li><p>解决：在pch文件中判断一下，如果是OC文件菜引入响应的宏，如果是普通C语言文件则不引入，否则项目中添加C语言文件时会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef __OBJC__</div><div class="line"></div><div class="line">// OC相关的内容</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/NSOperation/" itemprop="url">
                  NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Net/" itemprop="url" rel="index">
                    <span itemprop="name">Net</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/NSOperation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/NSOperation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、NSOperation简介"><a href="#一、NSOperation简介" class="headerlink" title="一、NSOperation简介"></a>一、NSOperation简介</h2><h4 id="1、NSOperation的作用"><a href="#1、NSOperation的作用" class="headerlink" title="1、NSOperation的作用"></a>1、NSOperation的作用</h4><ul>
<li>是OC语言中基于GCD的面向对象的封装</li>
<li>使用起来比GCD更加简单（面向对象）</li>
<li>提供了一些用GCD不好实现的功能</li>
<li>苹果推荐使用，使用NSOperation不用关心线程以及线程的生命周期</li>
</ul>
<h4 id="2、查看NSOperation的头文件"><a href="#2、查看NSOperation的头文件" class="headerlink" title="2、查看NSOperation的头文件"></a>2、查看NSOperation的头文件</h4><ul>
<li>NSOperation是一个抽象类<ol>
<li>不能直接使用（方法没有实现）</li>
<li>约束子类都具有共同的属性和方法</li>
</ol>
</li>
<li>NSOperation的子类<ol>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义operation</li>
</ol>
</li>
</ul>
<h4 id="3、使用步骤"><a href="#3、使用步骤" class="headerlink" title="3、使用步骤"></a>3、使用步骤</h4><h6 id="NSOperation和NSOperationQueue实现多线程的具体步骤"><a href="#NSOperation和NSOperationQueue实现多线程的具体步骤" class="headerlink" title="NSOperation和NSOperationQueue实现多线程的具体步骤"></a>NSOperation和NSOperationQueue实现多线程的具体步骤</h6><ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h2 id="二、NSOperation"><a href="#二、NSOperation" class="headerlink" title="二、NSOperation"></a>二、NSOperation</h2><h4 id="1、NSInvocationOperation"><a href="#1、NSInvocationOperation" class="headerlink" title="1、NSInvocationOperation"></a>1、NSInvocationOperation</h4><h6 id="建NSInvocationOperation对象"><a href="#建NSInvocationOperation对象" class="headerlink" title="建NSInvocationOperation对象"></a>建NSInvocationOperation对象</h6><pre><code>- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;
</code></pre><h6 id="调用start方法开始执行操作"><a href="#调用start方法开始执行操作" class="headerlink" title="调用start方法开始执行操作"></a>调用start方法开始执行操作</h6><pre><code>- (void)start;
</code></pre><p><strong>一旦执行操作，就会调用target的sel方法</strong></p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul>
<li>默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作</li>
<li>只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作,年代久远，不常用。</li>
</ul>
<h4 id="2、NSBlockOperation"><a href="#2、NSBlockOperation" class="headerlink" title="2、NSBlockOperation"></a>2、NSBlockOperation</h4><h6 id="创建NSBlockOperation对象"><a href="#创建NSBlockOperation对象" class="headerlink" title="创建NSBlockOperation对象"></a>创建NSBlockOperation对象</h6><pre><code>+ (id)blockOperationWithBlock:(void (^)(void))block;
</code></pre><h6 id="通过addExecutionBlock-方法添加更多的操作"><a href="#通过addExecutionBlock-方法添加更多的操作" class="headerlink" title="通过addExecutionBlock:方法添加更多的操作"></a>通过addExecutionBlock:方法添加更多的操作</h6><pre><code>- (void)addExecutionBlock:(void (^)(void))block;
</code></pre><p><strong>注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作</strong></p>
<h4 id="3、NSOperationQueue"><a href="#3、NSOperationQueue" class="headerlink" title="3、NSOperationQueue"></a>3、NSOperationQueue</h4><h6 id="NSOperationQueue的作用"><a href="#NSOperationQueue的作用" class="headerlink" title="NSOperationQueue的作用"></a>NSOperationQueue的作用</h6><pre><code>NSOperation可以调用start方法来执行任务，但默认是同步执行的
如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作
</code></pre><h6 id="添加操作到NSOperationQueue中"><a href="#添加操作到NSOperationQueue中" class="headerlink" title="添加操作到NSOperationQueue中"></a>添加操作到NSOperationQueue中</h6><pre><code>- (void)addOperation:(NSOperation *)op;
- (void)addOperationWithBlock:(void (^)(void))block;
</code></pre><h6 id="监听操作完成"><a href="#监听操作完成" class="headerlink" title="监听操作完成"></a>监听操作完成</h6><pre><code>可以监听一个操作的执行完毕
- (void (^)(void))completionBlock;
- (void)setCompletionBlock:(void (^)(void))block;
</code></pre><h4 id="4、最大并发数"><a href="#4、最大并发数" class="headerlink" title="4、最大并发数"></a>4、最大并发数</h4><h6 id="什么是并发数"><a href="#什么是并发数" class="headerlink" title="什么是并发数"></a>什么是并发数</h6><ul>
<li>同时执行的任务数</li>
<li>比如，同时开3个线程执行3个任务，并发数就是3</li>
</ul>
<h6 id="最大并发数的相关方法"><a href="#最大并发数的相关方法" class="headerlink" title="最大并发数的相关方法"></a>最大并发数的相关方法</h6><pre><code>- (NSInteger)maxConcurrentOperationCount;
- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;
</code></pre><h4 id="5、队列的暂停、取消、恢复"><a href="#5、队列的暂停、取消、恢复" class="headerlink" title="5、队列的暂停、取消、恢复"></a>5、队列的暂停、取消、恢复</h4><h6 id="取消队列的所有操作"><a href="#取消队列的所有操作" class="headerlink" title="取消队列的所有操作"></a>取消队列的所有操作</h6><pre><code>- (void)cancelAllOperations;
提示：也可以调用NSOperation的- (void)cancel方法取消单个操作
</code></pre><h6 id="暂停和恢复队列"><a href="#暂停和恢复队列" class="headerlink" title="暂停和恢复队列"></a>暂停和恢复队列</h6><pre><code>- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列
- (BOOL)isSuspended;
</code></pre><h4 id="6、操作的优先级"><a href="#6、操作的优先级" class="headerlink" title="6、操作的优先级"></a>6、操作的优先级</h4><h6 id="设置NSOperation在queue中的优先级，可以改变操作的执行优先级"><a href="#设置NSOperation在queue中的优先级，可以改变操作的执行优先级" class="headerlink" title="设置NSOperation在queue中的优先级，可以改变操作的执行优先级"></a>设置NSOperation在queue中的优先级，可以改变操作的执行优先级</h6><pre><code>- (NSOperationQueuePriority)queuePriority;
- (void)setQueuePriority:(NSOperationQueuePriority)p;
</code></pre><h6 id="优先级的取值"><a href="#优先级的取值" class="headerlink" title="优先级的取值"></a>优先级的取值</h6><pre><code>NSOperationQueuePriorityVeryLow = -8L,
NSOperationQueuePriorityLow = -4L,
NSOperationQueuePriorityNormal = 0,
NSOperationQueuePriorityHigh = 4,
NSOperationQueuePriorityVeryHigh = 8

iOS8 @property NSQualityOfService qualityOfService

NSQualityOfServiceUserInteractive = 0x21,
NSQualityOfServiceUserInitiated = 0x19,
NSQualityOfServiceUtility = 0x11,
NSQualityOfServiceBackground = 0x09,
NSQualityOfServiceDefault = -1
</code></pre><h4 id="7、操作依赖"><a href="#7、操作依赖" class="headerlink" title="7、操作依赖"></a>7、操作依赖</h4><h6 id="NSOperation之间可以设置依赖来保证执行顺序"><a href="#NSOperation之间可以设置依赖来保证执行顺序" class="headerlink" title="NSOperation之间可以设置依赖来保证执行顺序"></a>NSOperation之间可以设置依赖来保证执行顺序</h6><pre><code>比如一定要让操作A执行完后，才能执行操作B，可以这么写
[operationB addDependency:operationA]; // 操作B依赖于操作A
可以在不同queue的NSOperation之间创建依赖关系
</code></pre><p><strong>注意不能相符依赖</strong></p>
<h4 id="8、线程间通信"><a href="#8、线程间通信" class="headerlink" title="8、线程间通信"></a>8、线程间通信</h4><h6 id="子线程-gt-主线程"><a href="#子线程-gt-主线程" class="headerlink" title="子线程-&gt;主线程"></a>子线程-&gt;主线程</h6><pre><code>[self.queue addOperationWithBlock:^{
        //子线程
        //do something
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            //主线程的任务,操作UI等
        }];
    }];
</code></pre><h4 id="9、自定义NSOperation"><a href="#9、自定义NSOperation" class="headerlink" title="9、自定义NSOperation"></a>9、自定义NSOperation</h4><h6 id="重写main方法，把我们想要执行的代码放到该方法中去运行。"><a href="#重写main方法，把我们想要执行的代码放到该方法中去运行。" class="headerlink" title="重写main方法，把我们想要执行的代码放到该方法中去运行。"></a>重写main方法，把我们想要执行的代码放到该方法中去运行。</h6><pre><code>- (void)main;
</code></pre><h2 id="3、NSOperation-VS-GCD"><a href="#3、NSOperation-VS-GCD" class="headerlink" title="3、NSOperation VS GCD"></a>3、NSOperation VS GCD</h2><h4 id="1、GCD"><a href="#1、GCD" class="headerlink" title="1、GCD"></a>1、GCD</h4><pre><code>i.  GCD是iOS4.0 推出的，主要针对多核cpu做了优化，是C语言的技术
ii. GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数
iii.GCD提供了一些NSOperation不具备的功能
1.    一次性执行
2.    延迟执行
3.    调度组
</code></pre><h4 id="2、NSOperation"><a href="#2、NSOperation" class="headerlink" title="2、NSOperation"></a>2、NSOperation</h4><pre><code>i.  NSOperation是iOS2.0推出的，iOS4之后重写了NSOperation
ii.    NSOperation将操作(异步的任务)添加到队列(并发队列)，就会执行指定操作的函数
iii.NSOperation里提供的方便的操作
1.    最大并发数
2.    队列的暂定/继续
3.    取消所有的操作
4.    指定操作之间的依赖关系(GCD可以用同步实现)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/hexo常用命令笔记/" itemprop="url">
                  hexo常用命令笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/hexo常用命令笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/hexo常用命令笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><pre><code>npm install hexo -g #安装  
npm update hexo -g #升级  
hexo init #初始化
</code></pre><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章
hexo p == hexo publish
hexo g == hexo generate#生成
hexo s == hexo server #启动服务预览
hexo d == hexo deploy#部署
</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。
hexo server -s #静态模式
hexo server -p 5000 #更改端口
hexo server -i 192.168.1.1 #自定义 IP

hexo clean #清除缓存 网页正常情况下可以忽略此条命令
hexo g #生成静态网页
hexo d #开始部署
</code></pre><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><pre><code>hexo generate #使用 Hexo 生成静态文件快速而且简单
hexo generate --watch #监视文件变动
</code></pre><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><pre><code>两个命令的作用是相同的
hexo generate --deploy
hexo deploy --generate
</code></pre><p><code>hexo deploy -g</code><br><code>hexo server -g</code></p>
<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p><code>hexo publish [layout] &lt;title&gt;</code></p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p><code>hexo new &quot;postName&quot;</code> #新建文章</p>
<p><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #将.deploy目录部署到GitHub</p>
<p><code>hexo new [layout] &lt;title&gt;</code><br><code>hexo new photo &quot;My Gallery&quot;</code><br><code>hexo new &quot;Hello World&quot; --lang tw</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">layout</td>
<td style="text-align:left">布局</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">标题</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">文件建立日期</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">title: 使用Hexo搭建个人博客</div><div class="line">layout: post</div><div class="line">date: 2014-03-03 19:07:43</div><div class="line">comments: true</div><div class="line">categories: Blog</div><div class="line">tags: [Hexo]</div><div class="line">keywords: Hexo, Blog</div><div class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</div></pre></td></tr></table></figure>
<h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><p><code>hexo new photo &quot;My Gallery&quot;</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">layout</td>
<td style="text-align:left">布局</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">标题</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">文件建立日期</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h3><pre><code>以上是文章摘要 &lt;!--more--&gt; 以下是余下全文
</code></pre><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><code>hexo new page &lt;title&gt;</code><br><code>hexo new post &lt;title&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:title</td>
<td style="text-align:left">标题</td>
</tr>
<tr>
<td style="text-align:left">:year</td>
<td style="text-align:left">建立的年份（4 位数）</td>
</tr>
<tr>
<td style="text-align:left">:month</td>
<td style="text-align:left">建立的月份（2 位数）</td>
</tr>
<tr>
<td style="text-align:left">:i_month</td>
<td style="text-align:left">建立的月份（去掉开头的零）</td>
</tr>
<tr>
<td style="text-align:left">:day</td>
<td style="text-align:left">建立的日期（2 位数）</td>
</tr>
<tr>
<td style="text-align:left">:i_day</td>
<td style="text-align:left">建立的日期（去掉开头的零</td>
</tr>
</tbody>
</table>
<h3 id="推送到服务器上"><a href="#推送到服务器上" class="headerlink" title="推送到服务器上"></a>推送到服务器上</h3><p><code>hexo n</code> #写文章<br><code>hexo g</code> #生成<br><code>hexo d</code> #部署 #可与 <code>hexo g</code> 合并为 <code>hexo d -g</code></p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h4 id="1-找不到git部署"><a href="#1-找不到git部署" class="headerlink" title="1.找不到git部署"></a>1.找不到git部署</h4><pre><code>ERROR Deployer not found: git
</code></pre><p><strong>解决方法:</strong></p>
<p><code>npm install hexo-deployer-git --save</code></p>
<h4 id="2-部署类型设置git"><a href="#2-部署类型设置git" class="headerlink" title="2.部署类型设置git"></a>2.部署类型设置git</h4><p>hexo 3.0 部署类型不再是<code>github</code>，<code>_config.yml</code> 中修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: http://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@***.github.com:***/***.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<h4 id="3-Xcodebuild"><a href="#3-Xcodebuild" class="headerlink" title="3.Xcodebuild"></a>3.Xcodebuild</h4><p>xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance</p>
<p><code>npm install bcrypt</code></p>
<h4 id="4-RSS不显示"><a href="#4-RSS不显示" class="headerlink" title="4.RSS不显示"></a>4.RSS不显示</h4><p><strong>安装RSS插件</strong></p>
<p><code>npm install hexo-generator-feed --save</code></p>
<p><strong>开启RSS功能</strong></p>
<p>编辑hexo/_config.yml，添加如下代码：</p>
<pre><code>rss: /atom.xml #rss地址  默认即可
</code></pre><h4 id="5-开启评论"><a href="#5-开启评论" class="headerlink" title="5.开启评论"></a>5.开启评论</h4><p>1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</p>
<ol>
<li>在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</li>
<li>复制到 themes\landscape\layout_partial\article.ejs<br>把</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class="line">&lt;section id="comments"&gt;</div><div class="line">&lt;div id="disqus_thread"&gt;</div><div class="line">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href="//disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/section&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class="line">  &lt;section id="comments"&gt;</div><div class="line">    &lt;!-- 多说评论框 start --&gt;</div><div class="line">    &lt;div class="ds-thread" data-thread-key="&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;" data-title="&lt;%= post.title %&gt;" data-url="&lt;%= page.permalink %&gt;"&gt;&lt;/div&gt;</div><div class="line">    &lt;!-- 多说评论框 end --&gt;</div><div class="line">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</div><div class="line">    &lt;script type="text/javascript"&gt;</div><div class="line">    var duoshuoQuery = &#123;short_name:'&lt;%= config.disqus_shortname %&gt;'&#125;;</div><div class="line">      (function() &#123;</div><div class="line">        var ds = document.createElement('script');</div><div class="line">        ds.type = 'text/javascript';ds.async = true;</div><div class="line">        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';</div><div class="line">        ds.charset = 'UTF-8';</div><div class="line">        (document.getElementsByTagName('head')[0] </div><div class="line">         || document.getElementsByTagName('body')[0]).appendChild(ds);</div><div class="line">      &#125;)();</div><div class="line">      &lt;/script&gt;</div><div class="line">    &lt;!-- 多说公共JS代码 end --&gt;</div><div class="line">  &lt;/section&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/layoutsubviews/" itemprop="url">
                  LayoutSubViews
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/layoutsubviews/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/layoutsubviews/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="layoutSubviews总结"><a href="#layoutSubviews总结" class="headerlink" title="layoutSubviews总结"></a>layoutSubviews总结</h2><ul>
<li><p>1.iOS layout机制相关方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)sizeThatFits:(<span class="built_in">CGSize</span>)size</div><div class="line">- (<span class="keyword">void</span>)sizeToFit</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews</div><div class="line">- (<span class="keyword">void</span>)layoutIfNeeded</div><div class="line">- (<span class="keyword">void</span>)setNeedsLayout</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNeedsDisplay</div><div class="line">- (<span class="keyword">void</span>)drawRect</div></pre></td></tr></table></figure>
</li>
<li><p>2.layoutSubviews 被调用的情况</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>init 初始化时不会触发 layoutSubview, 但是使用 initWithFrame: 进行初始化时, 当 rect 的值不为 <span class="built_in">CGRectZero</span> 时, 会触发</div><div class="line"><span class="number">2.</span>addSubview 会触发 layoutSubviews</div><div class="line"><span class="number">3.</span>设置 view 的Frame 会触发 layoutSubviews, 前提是 Fraame的值前后发生变化</div><div class="line"><span class="number">4.</span>滚动一个 <span class="built_in">UIScrollView</span> 会触发 layoutSubviews</div><div class="line"><span class="number">5.</span>旋转 Screen 会触发 父View 上的 layoutSubviews 事件</div><div class="line"><span class="number">6.</span>改变一个 <span class="built_in">UIView</span> 大小的时候, 也会触发 父View 上的 layoutSubviews 事件</div><div class="line">在苹果的官方文档中强调:</div><div class="line">   You should override <span class="keyword">this</span> method only <span class="keyword">if</span> the autoresizing and constraint-based behaviors of the subviews <span class="keyword">do</span> not offer the behavior you want.</div><div class="line">   只要调整尺寸和基于约束的行为的子视图不提供你想要的行为时, 你应重写此方法</div></pre></td></tr></table></figure>
<ul>
<li>3.刷新子对象布局</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- layoutSubviews: 这个方法默认没有做任何事情, 需要子类进行重写</div><div class="line">- setNeedsLayout: 标记为需要重新布局, 异步调用 layoutIfNeeded 刷新布局, 不立即刷新, 但 layoutSubviews 一定会调用</div><div class="line">- layoutIfNeeded: 如果有需要刷新的标记, 立即调用 layoutSubviews 进行布局, 如果没有标记, 不会调用 layoutSubviews</div><div class="line">对于 layoutSubviews 文档中还指出:</div><div class="line">    You should not call <span class="keyword">this</span> method directly. If you want to force a layout update, call the setNeedsLayout method instead to <span class="keyword">do</span> so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method</div><div class="line">    你不应该直接调用该方法, 如果你想更新布局, 在更新布局之前调用 [view setNeedsLayout] 方法. 如果你想立即更新你的视图, 则调用 [view layoutIfNeeded] 方法.</div><div class="line">在视图第一次显示之前, 标记总是 <span class="string">"需要刷新"</span> 的, 可以直接调用 [view layoutIfNeeded]</div></pre></td></tr></table></figure>
<ul>
<li>4.重绘</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- drawRect:(<span class="built_in">CGRect</span>)rect: 重写此方法, 执行重绘任务</div><div class="line">- setNeedsDisplay: 标记为需要重绘, 异步调用 drawRect: 方法</div><div class="line">- setNeedsDisolayInRect:(<span class="built_in">CGRect</span>)invalidRect: 标记需要局部重绘</div></pre></td></tr></table></figure>
<ul>
<li>5.sizeToFit 与 sizeThatFits:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sizeToFit</div><div class="line">sizeToFit 可以被手动直接调用</div><div class="line">调用 sizeToFit 会自动调用 sizeThatFits: 方法</div><div class="line">sizeToFit 不应该在子类中被重写, 应该重写 - (<span class="built_in">CGSize</span>)sizeThatFits:(<span class="built_in">CGSize</span>)size</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  调整尺寸</div><div class="line"> *</div><div class="line"> *  @param size receiver当前的尺寸</div><div class="line"> *</div><div class="line"> *  @return 返回一个合适的尺寸</div><div class="line"> */</div><div class="line">- (<span class="built_in">CGSize</span>)sizeThatFits:(<span class="built_in">CGSize</span>)size</div></pre></td></tr></table></figure>
<ul>
<li>6.layoutSubviews 与 drawRect</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">layoutSubviews 对 subviews 重新布局</div><div class="line"></div><div class="line">layoutSubviews 方法调用先于 drawRect</div><div class="line"></div><div class="line">setNeedsLayout 在receiver标上一个需要被重新布局的标记，在系统 runloop 的下一个周期自动调用 layoutSubviews</div><div class="line"></div><div class="line">layoutIfNeeded 方法如其名，<span class="built_in">UIKit</span> 会判断该receiver是否需要 layout.根据Apple官方文档, layoutIfNeeded 方法应该是这样的</div><div class="line"></div><div class="line">layoutIfNeeded 遍历的不是 superview 链，应该是 subviews 链</div><div class="line"></div><div class="line">drawRect 是对receiver的重绘，能获得 context</div><div class="line"></div><div class="line">setNeedDisplay 在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是<span class="number">60</span>hz，也就是<span class="number">1</span>/<span class="number">60</span>秒后重绘</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/多线程的基本概念/" itemprop="url">
                  多线程概念和NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:38:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Net/" itemprop="url" rel="index">
                    <span itemprop="name">Net</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/多线程的基本概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/多线程的基本概念/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、多线程的基本概念"><a href="#一、多线程的基本概念" class="headerlink" title="一、多线程的基本概念"></a>一、多线程的基本概念</h2><h4 id="1、多线程的基本概念"><a href="#1、多线程的基本概念" class="headerlink" title="1、多线程的基本概念"></a>1、多线程的基本概念</h4><ol>
<li>同步:顺序执行</li>
<li>异步:同时运行</li>
<li>进程:正在运行的程序,一个或多个线程组成</li>
<li>线程:最基本的执行单元</li>
</ol>
<h4 id="2、特征"><a href="#2、特征" class="headerlink" title="2、特征"></a>2、特征</h4><ul>
<li>(单核CPU)同一时间,cpu只能处理1个线程,只有1个线程在执行 </li>
<li>多线程同时执行:是CPU快速的在多个线程之间的切换</li>
<li>cpu调度线程的时间足够快,就造成了多线程的“同时”执行</li>
<li>如果线程数非常多,cpu会在n个线程之间切换,消耗大量的cpu资源 </li>
<li>每个线程被调度的次数会降低,线程的执行效率降低 </li>
</ul>
<h6 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h6><ul>
<li>能<strong>适当</strong>提高程序的执行效率</li>
<li>能<strong>适当</strong>提高资源的利用率（CPU&amp;内存）</li>
<li>线程上得任务执行完后自动销毁</li>
</ul>
<h6 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h6><ul>
<li>开启线程需要占用一定的内存空间(默认情况下,每一个线程都占512KB) </li>
<li>如果开启大量的线程,会占用大量的内存空间,降低程序的性能</li>
<li>线程越多,cpu在调用线程上的开销就越大</li>
<li>程序设计更加复杂,比如线程间的通信、多线程的数据共享 </li>
<li><strong>时间成本和空间成本</strong></li>
</ul>
<h6 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h6><ul>
<li>一个程序运行后,默认会开启1个线程,称为“主线程”或“UI线程”</li>
<li>主线程一般用来 刷新UI界面 ,处理UI事件(比如:点击、滚动、拖拽等事件) </li>
<li>主线程使用注意 <ul>
<li>别将耗时的操作放到主线程中</li>
<li>耗时操作会卡住主线程,严重影响UI的流畅度,给用户一种卡的坏体验</li>
</ul>
</li>
</ul>
<h2 id="二、NSThread"><a href="#二、NSThread" class="headerlink" title="二、NSThread"></a>二、NSThread</h2><h4 id="1、创建和启动线程"><a href="#1、创建和启动线程" class="headerlink" title="1、创建和启动线程"></a>1、创建和启动线程</h4><p><strong>一个NSThread对象就代表一条线程</strong></p>
<h6 id="创建、启动线程"><a href="#创建、启动线程" class="headerlink" title="创建、启动线程"></a>创建、启动线程</h6><pre><code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];
[thread start];
// 线程一启动，就会在线程thread中执行self的run方法
</code></pre><h6 id="其他创建线程方式"><a href="#其他创建线程方式" class="headerlink" title="其他创建线程方式"></a>其他创建线程方式</h6><p>1、创建线程后自动启动线程</p>
<pre><code>[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];
</code></pre><p>2、隐式创建并启动线程</p>
<pre><code>[self performSelectorInBackground:@selector(run) withObject:nil];
</code></pre><p>3、上述2种创建线程方式的优缺点</p>
<pre><code>优点：简单快捷
缺点：无法对线程进行更详细的设置
</code></pre><h4 id="2、控制线程状态"><a href="#2、控制线程状态" class="headerlink" title="2、控制线程状态"></a>2、控制线程状态</h4><h6 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h6><pre><code>- (void)start; 
</code></pre><p>// 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</p>
<h6 id="阻塞（暂停）线程"><a href="#阻塞（暂停）线程" class="headerlink" title="阻塞（暂停）线程"></a>阻塞（暂停）线程</h6><pre><code>+ (void)sleepUntilDate:(NSDate *)date;
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;
</code></pre><p>// 进入阻塞状态</p>
<h6 id="强制停止线程"><a href="#强制停止线程" class="headerlink" title="强制停止线程"></a>强制停止线程</h6><pre><code>+ (void)exit;
</code></pre><p>// 进入死亡状态</p>
<p><strong>注意：一旦线程停止（死亡）了，就不能再次开启任务</strong></p>
<h4 id="3、常用属性方法"><a href="#3、常用属性方法" class="headerlink" title="3、常用属性方法"></a>3、常用属性方法</h4><h6 id="获得当前线程"><a href="#获得当前线程" class="headerlink" title="获得当前线程"></a>获得当前线程</h6><pre><code>NSThread *current = [NSThread currentThread];
</code></pre><h6 id="线程的调度优先级"><a href="#线程的调度优先级" class="headerlink" title="线程的调度优先级"></a>线程的调度优先级</h6><pre><code>+ (double)threadPriority;
</code></pre><p>调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高</p>
<h6 id="线程的名字"><a href="#线程的名字" class="headerlink" title="线程的名字"></a>线程的名字</h6><pre><code>- (void)setName:(NSString *)n;
- (NSString *)name;
</code></pre><h6 id="主线程相关用法"><a href="#主线程相关用法" class="headerlink" title="主线程相关用法"></a>主线程相关用法</h6><pre><code>+ (NSThread *)mainThread; // 获得主线程
- (BOOL)isMainThread; // 是否为主线程
</code></pre><h4 id="4、多线程的安全隐患"><a href="#4、多线程的安全隐患" class="headerlink" title="4、多线程的安全隐患"></a>4、多线程的安全隐患</h4><h6 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h6><ul>
<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>
</ul>
<h4 id="5、安全隐患解决-–-互斥锁"><a href="#5、安全隐患解决-–-互斥锁" class="headerlink" title="5、安全隐患解决 – 互斥锁"></a>5、安全隐患解决 – 互斥锁</h4><h6 id="互斥锁使用格式"><a href="#互斥锁使用格式" class="headerlink" title="互斥锁使用格式"></a>互斥锁使用格式</h6><pre><code>@synchronized(锁对象) { // 需要锁定的代码  }
</code></pre><p><strong>注意：锁定1份代码只用1把锁，用多把锁是无效的</strong></p>
<h6 id="互斥锁的优缺点"><a href="#互斥锁的优缺点" class="headerlink" title="互斥锁的优缺点"></a>互斥锁的优缺点</h6><pre><code>优点：能有效防止因多线程抢夺资源造成的数据安全问题
缺点：需要消耗大量的CPU资源
</code></pre><p><strong>互斥锁的使用前提：多条线程抢夺同一块资源</strong></p>
<h6 id="相关专业术语：线程同步"><a href="#相关专业术语：线程同步" class="headerlink" title="相关专业术语：线程同步"></a>相关专业术语：线程同步</h6><pre><code>线程同步的意思是：多条线程按顺序地执行任务
互斥锁，就是使用了线程同步技术
</code></pre><h4 id="6、原子和非原子属性"><a href="#6、原子和非原子属性" class="headerlink" title="6、原子和非原子属性"></a>6、原子和非原子属性</h4><h6 id="OC在定义属性时有nonatomic和atomic两种选择"><a href="#OC在定义属性时有nonatomic和atomic两种选择" class="headerlink" title="OC在定义属性时有nonatomic和atomic两种选择"></a>OC在定义属性时有nonatomic和atomic两种选择</h6><ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>
<h4 id="7、线程间通信"><a href="#7、线程间通信" class="headerlink" title="7、线程间通信"></a>7、线程间通信</h4><h6 id="什么叫做线程间通信"><a href="#什么叫做线程间通信" class="headerlink" title="什么叫做线程间通信"></a>什么叫做线程间通信</h6><p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信</p>
<h6 id="线程间通信的体现"><a href="#线程间通信的体现" class="headerlink" title="线程间通信的体现"></a>线程间通信的体现</h6><ul>
<li>1个线程传递数据给另1个线程</li>
<li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li>
</ul>
<h6 id="线程间通信常用方法"><a href="#线程间通信常用方法" class="headerlink" title="线程间通信常用方法"></a>线程间通信常用方法</h6><pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;
</code></pre><h4 id="8、什么时候使用自动释放池"><a href="#8、什么时候使用自动释放池" class="headerlink" title="8、什么时候使用自动释放池"></a>8、什么时候使用自动释放池</h4><p><strong>If you write a loop that creates many temporary objects.</strong><br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application. </p>
<p>循环中创建了许多临时对象，在循环里面使用自动释放池，用来减少高内存占用。</p>
<p><strong>If you spawn a secondary thread.</strong><br>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.) </p>
<p>开启子线程的时候要自己创建自动释放池，否则可能会发生内存泄露</p>
<h6 id="自动释放池常见面试代码"><a href="#自动释放池常见面试代码" class="headerlink" title="自动释放池常见面试代码"></a>自动释放池常见面试代码</h6><pre><code>for (int i = 0; i &lt; largeNumber; ++i) {
    NSString *str = @&quot;Hello World&quot;;
    str = [str stringByAppendingFormat:@&quot; - %d&quot;, i];
    str = [str uppercaseString];
    NSLog(@&quot;%@&quot;, str);
}
</code></pre><p><strong>在for循环内部加入一个自动释放池</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=697890588,3646918970&fm=116&gp=0.jpg"
               alt="颜文字" />
          <p class="site-author-name" itemprop="name">颜文字</p>
          <p class="site-description motion-element" itemprop="description">颜貌岁岁改，波澜誓不起。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">59</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanhuangzisuen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/yanyan767006743" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">颜文字</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yancode"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
