<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="颜貌岁岁改，波澜誓不起。">
<meta property="og:type" content="website">
<meta property="og:title" content="℡颜文字♡">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="℡颜文字♡">
<meta property="og:description" content="颜貌岁岁改，波澜誓不起。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="℡颜文字♡">
<meta name="twitter:description" content="颜貌岁岁改，波澜誓不起。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> ℡颜文字♡ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">℡颜文字♡</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'iRPRT9JgJfvxEsHZRgKm','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/C语言/" itemprop="url">
                  C语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T10:39:40+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/01/C语言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/01/C语言/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数组的打印</span></div><div class="line"><span class="keyword">void</span> printArr(<span class="keyword">int</span> a[],<span class="keyword">int</span> num)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</div><div class="line">    printf(<span class="string">"a[%d] = %d\n"</span>, i, a[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> test1()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">78</span>, <span class="number">27</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">59</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">53</span>&#125;;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = a[j + <span class="number">1</span>];</div><div class="line">                a[j + <span class="number">1</span>] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printArr(a, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> test2()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">78</span>, <span class="number">27</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">59</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">53</span>&#125;;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = a[j];</div><div class="line">                a[j] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printArr(a, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> test3()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">78</span>, <span class="number">27</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">59</span>, <span class="number">99</span>, <span class="number">68</span>, <span class="number">53</span>&#125;;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">int</span> temp = a[i];</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) <span class="keyword">break</span>;<span class="comment">//需要在J这个位置进行插入</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//if(j &lt; i)&#123;// 此if判断多余，与k = i - 1,k &gt;= j;重复</span></div><div class="line">            <span class="comment">//把该向后移动的元素向后移动</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= j; k--) &#123;</div><div class="line">            a[k + <span class="number">1</span>] = a[k];</div><div class="line">        &#125;</div><div class="line">        a[j] = temp;</div><div class="line">       <span class="comment">// &#125;</span></div><div class="line">    &#125;</div><div class="line">    printArr(a, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/ios面试题集/" itemprop="url">
                  ios面试题集
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T15:22:55+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/19/ios面试题集/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/ios面试题集/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、OC基本概念"><a href="#一、OC基本概念" class="headerlink" title="一、OC基本概念"></a>一、OC基本概念</h1><h3 id="1-static-关键字的作用"><a href="#1-static-关键字的作用" class="headerlink" title="1.static 关键字的作用"></a>1.static 关键字的作用</h3><p>（1）函数体内 <strong>static</strong> 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次， 因此其值在下次调用时仍维持上次的值；<br>（2）在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；<br>（3）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； </p>
<h3 id="2-关键字const有什么含义"><a href="#2-关键字const有什么含义" class="headerlink" title="2.关键字const有什么含义"></a>2.关键字const有什么含义</h3><p>const意味着“只读”<br>本质：const在谁后面谁就不可修改，const在最前面则将其后移一位即可,二者等效</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，指向的整型数是不可修改的，但指针可以，此最常见于函数的参数，当你只引用传进来指针所指向的值时应该加上const修饰符，程序中修改编译就不通过，可以减少程序的bug）。<br>第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。<br>const关键字至少有下列n个作用：<br>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> classA operator*(<span class="keyword">const</span> classA&amp; a1,<span class="keyword">const</span> classA&amp; a2); </div><div class="line">　　operator*的返回结果必须是一个<span class="keyword">const</span>对象。如果不是，这样的变态代码也不会编译出错：</div><div class="line">classA a, b, c;</div><div class="line">(a * b) = c; <span class="comment">// 对a*b的结果赋值 </span></div><div class="line">操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。</div></pre></td></tr></table></figure>
<h3 id="3-OC中有哪些数据存储方式-各有什么区别"><a href="#3-OC中有哪些数据存储方式-各有什么区别" class="headerlink" title="3.OC中有哪些数据存储方式,各有什么区别"></a>3.OC中有哪些数据存储方式,各有什么区别</h3><p><strong>四种存储方式: </strong><br>1.NSUserDefaults,用于存储配置信息<br>2.SQLite,用于存储查询需求较多的数据<br>3.CoreData,用于规划应用中的对象(第三方库MagicalRecord)<br>4.使用基本对象类型定制的个性化缓存方案.<br>NSUserDefaults:对象中储存了系统中用户的配置信息,开发者可以通过这个实例对象对这些已有的信息进行修改,也 可以按照自己的需求创建新的配置项。<br>SQLite擅长处理的数据类型其实与NSUserDefaults差不多,也是基础类型的小数据,只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据,使用SQL DML来管理数据。一般来说应用中的格式化的文本类数据可以存放在数据库 中,尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。<br>CoreData是一个管理方案,它的持久化可以通过SQLite、XML或二进制文件储存。它可以把整个应用中的对象建模并进 行自动化的管理。从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存,而是根据运行时状 态,把被调用到的对象实例载入内存。框架会自动控制这个过程,从而达到控制内存消耗,避免浪费。 无论从设计原理还是使用方法上看,CoreData都比较复杂。因此,如果仅仅是考虑缓存数据这个需求,CoreData绝对不 是一个优选方案。CoreData的使用场景在于:整个应用使用CoreData规划,把应用内的数据通过CoreData建模,完全 基于CoreData架构应用。<br>使用基本对象类型定制的个性化缓存方案:从需求出发分析缓存数据有哪些要求:按Key查找,快速读取,写入不影响正常 操作,不浪费内存,支持归档。这些都是基本需求,那么再进一步或许还需要固定缓存项数量,支持队列缓存,缓存过期等。</p>
<h3 id="4-ios平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗"><a href="#4-ios平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗" class="headerlink" title="4.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?"></a>4.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?</h3><p><strong>iOS中可以有四种持久化数据的方式: 属性列表、对象归档、SQLite3和Core Data</strong><br>coredata可以使你以图形界面的方式快速的定义app的数据模型,同时在你的代码中容易获取到它。coredata提供了基础结构去处 理常用的功能,例如保存,恢复,撤销和重做,允许你在app中继续创建新的任务。在使用coredata的时候,你不用安装额外的数据 库系统,因为coredata使用内置的sqlite数据库。coredata将你app的模型层放入到一组定义在内存中的数据对象。coredata会 追踪这些对象的改变,同时可以根据需要做相应的改变,例如用户执行撤销命令。当coredata在对你app数据的改变进行保存的时 候,core data会把这些数据归档,并永久性保存。<br>mac os x中sqlite库,它是一个轻量级功能强大的关系数据引擎,也很容易嵌入到应用程序。可以在多个平台使用,sqlite是一个轻 量级的嵌入式sql数据库编程。与coredata框架不同的是,sqlite是使用程序式的,sql的主要的API来直接操作数据表。<br>Core Data不是一个关系型数据库,也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型, 但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系。</p>
<h3 id="5-堆栈的区别（Heap是堆，stack是栈）"><a href="#5-堆栈的区别（Heap是堆，stack是栈）" class="headerlink" title="5.堆栈的区别（Heap是堆，stack是栈）"></a>5.堆栈的区别（Heap是堆，stack是栈）</h3><p>(1)管理方式:对于栈来讲,是由编译器自动管理,无需我们手工控制;对于堆来说,释放工作由程序员控制,容易产生 memory leak。<br>(2)申请大小:能从栈获得的空间较小,堆是向高地址扩展的数据结构,是不连续的内存区域。堆的大小受限于计算机系统中 有效的虚拟内存。由此可见,堆获得的空间比较灵活,也比较大。<br>(3)碎片问题:对于堆来讲,频繁的new/delete势必会造成内存空间的不连续,从而造成大量的碎片,使程序效率降低。 对于栈来讲,则不会存在这个问题,因为栈是先进后出的队列,他们是如此的一一对应,以至于永远都不可能有一个内存块 从栈中间弹出<br>(4)分配方式:堆都是动态分配的,没有静态分配的堆。栈有2种分配方式:静态分配和动态分配。静态分配是编译器完成 的,比如局部变量的分配。动态分配由 alloca函数进行分配,但是栈的动态分配和堆是不同的,他的动态分配是由编译器 进行释放,无需我们手工实现。<br>(5)分配效率:栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈 都有专门的指令执行,这就决定了栈的效率比较高。堆则是C/C++函数库提供的,它的机制是很复杂的。  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。Stack空间有限，Heap是很大的自由存储区  </div><div class="line">C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。  </div><div class="line">程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行</div></pre></td></tr></table></figure>
<h3 id="6-面向对象的三大特征-并作简单的介绍"><a href="#6-面向对象的三大特征-并作简单的介绍" class="headerlink" title="6.面向对象的三大特征,并作简单的介绍"></a>6.面向对象的三大特征,并作简单的介绍</h3><p><strong>面向对象的三个基本特征是:封装、继承、多态。</strong><br>封装是面向对象的特征之一,是对象和类概念的主要特性。 封装,也就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏。隐藏对象的属性和实现细节,仅对外公开接口,提高代 码安全性,封装程度越高,独立性越强,使用越方便。<br>继承是指这样一种能力:它可以使用现有类的所有功能,并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过 继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”<br>多态性:允许你将父对象设置成为和一个或更多的他的子对象相等的技术,赋值之后,父对象就可以根据当前赋值给它的子 对象的特性以不同的方式运作。简单的说,就是一句话:<strong>允许将子类类型的指针赋值给父类类型的指针</strong></p>
<h3 id="7-我们说的obc是动态运行时语言是什么意思"><a href="#7-我们说的obc是动态运行时语言是什么意思" class="headerlink" title="7.我们说的obc是动态运行时语言是什么意思"></a>7.我们说的obc是动态运行时语言是什么意思</h3><p><strong>多态</strong>。主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实涉及到两个概念,运行时和多态。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。多态:不同对象以自己的方式响应 相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;那人类属于生物,猪也属于生物,都 继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础</p>
<h3 id="8-readwrite-readonly-assign-retain-copy-nonatomic-、strong、weak属性的作用-并区别strong-强引用-、-weak-弱引用-什么情况使用copy-assign-和retain"><a href="#8-readwrite-readonly-assign-retain-copy-nonatomic-、strong、weak属性的作用-并区别strong-强引用-、-weak-弱引用-什么情况使用copy-assign-和retain" class="headerlink" title="8.readwrite,readonly,assign,retain,copy,nonatomic 、strong、weak属性的作用?并区别strong(强引用)、 weak(弱引用)?什么情况使用copy,assign,和retain?"></a>8.readwrite,readonly,assign,retain,copy,nonatomic 、strong、weak属性的作用?并区别strong(强引用)、 weak(弱引用)?什么情况使用copy,assign,和retain?</h3><p>readwrite 是可读可写特性;需要生成getter方法和setter方法时<br>readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变<br>assign 是赋值特性,setter方法将传入参数赋值给实例变量;仅设置变量时;<br>retain 表示持有特性,setter方法将传入参数先保留,再赋值,传入参数的retaincount会+1;<br>copy 表示赋值特性,setter方法将传入对象复制一份;需要完全一份新的变量时。<br>nonatomic 非原子操作,决定编译器生成的setter getter是否是原子操作,atomic表示多线程安全,一般使用 nonatomic<br>assign用于简单数据类型,如NSInteger,double,bool。<br>retain 和copy用户对象,copy用于当 a指向一个对象,b也想指向同样的对象的时候,如果用assign,a如果释放,再 调用b会crash,如果用copy 的方式,a和b各自有自己的内存,就可以解决这个问题。retain 会使计数器加1,也可以解 决assign的问题。另外:atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。 在多线程环境 下,原子操作是必要的,否则有可能引起错误的结果。</p>
<h3 id="9-分别描述内存管理要点、autorelease、release、NSAutoreleasePool-并说明autorelease是什-么时候被release的-简述什么时候由你负责释放对象-什么时候不由你释放-NSAutoreleasePool-release-和-NSAutoreleasePool-drain-有什么区别"><a href="#9-分别描述内存管理要点、autorelease、release、NSAutoreleasePool-并说明autorelease是什-么时候被release的-简述什么时候由你负责释放对象-什么时候不由你释放-NSAutoreleasePool-release-和-NSAutoreleasePool-drain-有什么区别" class="headerlink" title="9.分别描述内存管理要点、autorelease、release、NSAutoreleasePool?并说明autorelease是什 么时候被release的?简述什么时候由你负责释放对象,什么时候不由你释放?[NSAutoreleasePool release]和[NSAutoreleasePool drain]有什么区别?"></a>9.分别描述内存管理要点、autorelease、release、NSAutoreleasePool?并说明autorelease是什 么时候被release的?简述什么时候由你负责释放对象,什么时候不由你释放?[NSAutoreleasePool release]和[NSAutoreleasePool drain]有什么区别?</h3><p><strong>内存管理要点:</strong><br>内存管理:管理堆区内存的分配和释放；<br>Objective-C 使用引用计数机制(retainCount)来管理内存。内存每被引用一次,该内存的引用计数+1,每被释放一次引 用计数-1。当引用计数 = 0 的时候,调用该对象的 dealloc 方法,来彻底从内存中删除该对象。<br>alloc,allocWithZone,new(带初始化)时:该对象引用计数 +1;<br>retain:手动为该对象引用计数 +1;<br>copy:对象引用计数 +1;<br>mutableCopy:生成一个新对象,新对象引用计数为 1;<br>release:手动为该对象引用计数 -1; autorelease:把该对象放入自动释放池,当自动释放池释放时,其内的对象引用计数 -1。<br><strong>NSAutoreleasePool:</strong><br>NSAutoreleasePool是通过接收对象向它发送的autorelease消息,记录该对象的release消息,当自动释放池被销毁 时,会自动向池中的对象发送release消息。<br>autorelease 是在自动释放池被销毁,向池中的对象发送release<br>只能释放自己拥有的对象,<br><strong>区别是</strong>:在引用计数环境下(在不使用ARC情况下),两者基本一样,在GC环境下,release 是一个no-op(无效操 作),所以无论是不是gc都使用drain</p>
<h3 id="10-浅复制和深复制的区别"><a href="#10-浅复制和深复制的区别" class="headerlink" title="10.浅复制和深复制的区别"></a>10.浅复制和深复制的区别</h3><p>浅层复制(copy):只复制指向对象的指针,而不复制引用对象本身。//通过对象的指针来访问这个对象—-只复制地址<br>深层复制(mutableCopy):复制引用对象本身—再创建一个对象 意思就是有个A对象,复制一份后得到A_copy对象后,对于浅复制来说,A和A_copy指向的是同一个内存资源,复制的 只不过是是一个指针,对象本身资源 还是只有一份,那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改,这其实违背了我们复制拷贝的一 个思想。深复制就好理解了,内存中存在了<br>两份独立对象本身。//当修改A时,A copy不变</p>
<h3 id="11-什么是安全释放"><a href="#11-什么是安全释放" class="headerlink" title="11.什么是安全释放"></a>11.什么是安全释放</h3><p>MRC中，要释放一个对象<br>[obj release]; 释放对象之后，不会修改对象的指针地址，后续如果给 obj 发送消息，就会出现也指针错误<br>[obj nil]; 对象地址已经指向NULL，这个时候再发任何消息也不会报错。<br>僵尸对象：已经被释放的对象<br>野指针：指向僵尸对象的指针<br>空指针：nil，给空指针发送任何消息都不会报错</p>
<h3 id="12-NULL与nil-NSNULL"><a href="#12-NULL与nil-NSNULL" class="headerlink" title="12.NULL与nil/NSNULL"></a>12.NULL与nil/NSNULL</h3><p>nil：是地址指向NULL的空对象，在OC/C++中，给nil对象发送任何消息，都不会报错<br>NULL：是空地址，本身就是0,就是一个整数，不能给NULL发送消息<br>NSNULL：[NSNULL null]; 用处：就是向NSDictionary/NSArray中添加空对象使用的，只要用在通过运行时机制或KVC动态给对象属性设置数值时使用</p>
<h3 id="13-obj-c的优缺点"><a href="#13-obj-c的优缺点" class="headerlink" title="13.obj-c的优缺点"></a>13.obj-c的优缺点</h3><p><strong>objc优点：</strong><br>  1) Cateogies<br>  2) Posing<br>  3) 动态识别<br>  4) Objective-C 与 C++ 可混合编程<br><strong>缺点:</strong><br>  1) 不支持命名空间<br>  2)  不支持运算符重载<br>  3）不支持多重继承<br>  4）使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。</p>
<h3 id="14-什么时候用delegate，什么时候用Notification？"><a href="#14-什么时候用delegate，什么时候用Notification？" class="headerlink" title="14.什么时候用delegate，什么时候用Notification？"></a>14.什么时候用delegate，什么时候用Notification？</h3><p>答：delegate针对one-to-one关系，并且reciever可以返回值 给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到 reciever的某个功能反馈值，notification用于通知多个object某个事件。 </p>
<h3 id="15-什么是KVC和KVO"><a href="#15-什么是KVC和KVO" class="headerlink" title="15.什么是KVC和KVO"></a>15.什么是KVC和KVO</h3><p>KVC:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。<br>KVC(Key-Value-Coding)内部的实现：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。<br>KVO:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码<br>KVO（Key-Value- Observing）：当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以 isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名<br>的类名<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"highlighted"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>];   </div><div class="line"><span class="meta">#pragma mark KVO   </span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">	<span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"highlighted"</span>]) &#123;</div><div class="line">	[<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="16-KVO的底层实现原理（runTime运行时）"><a href="#16-KVO的底层实现原理（runTime运行时）" class="headerlink" title="16.KVO的底层实现原理（runTime运行时）"></a>16.KVO的底层实现原理（runTime运行时）</h3><p>1.（添加监听者时）保存所有参数（监听者、枚举、携带参数、路径）<br>2.创建子类NSKVONotifying-（类名），并重写set方法<br>3.set方法，监听者底层调用自己的observeValueForKeyPath</p>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>Notification 是观察者模式的实现,KVO是观察者模式的OB-C底层实现。<br>NOtification 通过 Notifydcation addobserver 和 remove observer 工作。<br>KVO是键值监听,键值观察机制,提供了观察某一属性变化的方法<br>KVC是键值编码,是一种间接访问对象的属性,使用字符串来标示属性(例如:setValue:forKey:)<br>Delegate:把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理,代替它来打理要做的事。反映到程序中,首先要明确一个对象的委托方是哪个对象,委托所做的内容是什么。</p>
<h3 id="17-类别的作用？继承和类别在实现中有何区别？"><a href="#17-类别的作用？继承和类别在实现中有何区别？" class="headerlink" title="17.类别的作用？继承和类别在实现中有何区别？"></a>17.类别的作用？继承和类别在实现中有何区别？</h3><p>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。<br>类别主要有3个作用：<br>(1)将类的实现分散到多个不同文件或多个不同框架中。<br>(2)创建对私有方法的前向引用。<br>(3)向对象添加非正式协议。<br>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
<h3 id="18-类别和类扩展的区别"><a href="#18-类别和类扩展的区别" class="headerlink" title="18.类别和类扩展的区别"></a>18.类别和类扩展的区别</h3><p>category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。分类的小括号中必须有名字，分类只能扩充方法，不能扩充属性和成员变量。(Category只能为对象添加方法,却不能添加成员变量的原因:如果可以添加成员变量,添加的成员变量没有办法初始 化—-这是语言规则)<br>extensions可以认为是一个私有的Category<br><strong>分类中能不能添加属性呢？</strong><br>如果通过@Property给分类新增属性，那么@property只会生成该属性的getter和setter方法的声明，而不会生成属性和实现方法。</p>
<h3 id="19-为什么不能包含分类的-m文件"><a href="#19-为什么不能包含分类的-m文件" class="headerlink" title="19.为什么不能包含分类的.m文件"></a>19.为什么不能包含分类的.m文件</h3><p>因为这样会重复包含另一个类的实现文件</p>
<h3 id="20-方法和选择器有何不同"><a href="#20-方法和选择器有何不同" class="headerlink" title="20.方法和选择器有何不同"></a>20.方法和选择器有何不同</h3><p>selector是一个方法的名字，method是一个组合体，包含了名字和实现</p>
<h3 id="21-OC有多继承吗-没有的话可以用什么方法替—多继承即一个子类可以有多个父类-它继承了多个父类的特性。"><a href="#21-OC有多继承吗-没有的话可以用什么方法替—多继承即一个子类可以有多个父类-它继承了多个父类的特性。" class="headerlink" title="21.OC有多继承吗?没有的话可以用什么方法替—多继承即一个子类可以有多个父类,它继承了多个父类的特性。"></a>21.OC有多继承吗?没有的话可以用什么方法替—多继承即一个子类可以有多个父类,它继承了多个父类的特性。</h3><p>Object-c的类没有多继承,只支持单继承,如果要实现多继承的话,可以通过类别和协议的方式来实现,OC类似于多继承,是在用protocol委托代理来实现的;可以实现多个接口,通过实现多个接口可以完成C++的多重继承;Category是类别,一 般情况用分类好,用Category去重写类的方法,仅对本Category有效,不会影响到其他类与原有类的关系。</p>
<h3 id="22-Objective-C有私有方法么-私有变量呢-如多没有的话-有没有什么代替的方法"><a href="#22-Objective-C有私有方法么-私有变量呢-如多没有的话-有没有什么代替的方法" class="headerlink" title="22.Objective-C有私有方法么?私有变量呢?如多没有的话,有没有什么代替的方法?"></a>22.Objective-C有私有方法么?私有变量呢?如多没有的话,有没有什么代替的方法?</h3><p>objective-c类里面的方法只有两种, 静态方法和实例方法.但是可以通过把方法的声明和定义都放在.m文件中来实现一个表面上的私有方法。有私有变量,可以通过@private来修饰,或者把声明放到.m文件中。在Objective‐C中,所有实例变 量默认都是私有的,所有实例方法默认都是公有的</p>
<h3 id="23-import、-include和-class有什么区别"><a href="#23-import、-include和-class有什么区别" class="headerlink" title="23.#import、#include和@class有什么区别"></a>23.#import、#include和@class有什么区别</h3><p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到,它只是声明了一个类名,关于这个类的内部实现都没 有告诉编译器,在m文件中还是需要使用#import。<br>而#import比起#include的好处就是不会引起交叉编译。</p>
<h3 id="24-谈谈你对MVC的理解-为什么要用MVC-在Cocoa中MVC是怎么实现的-你还熟悉其他的OC设计模式或别-的设计模式吗"><a href="#24-谈谈你对MVC的理解-为什么要用MVC-在Cocoa中MVC是怎么实现的-你还熟悉其他的OC设计模式或别-的设计模式吗" class="headerlink" title="24.谈谈你对MVC的理解?为什么要用MVC?在Cocoa中MVC是怎么实现的?你还熟悉其他的OC设计模式或别 的设计模式吗?"></a>24.谈谈你对MVC的理解?为什么要用MVC?在Cocoa中MVC是怎么实现的?你还熟悉其他的OC设计模式或别 的设计模式吗?</h3><p>MVC就是Model-View-Controller的缩写,M指的是业务模型,V指的是用户页面,C指的是控制器。MVC是架构模式,是讲M和 V的代码分离,从而使同那个一个程序可以使用不同的表现形式。<br>M:表示数据和业务规则,V是用户看到的并与之交互的页面,C是接受用户的输入并调用M和V取完成用户需求的 单例,代理,观察者,工厂模式等<br>单例模式:说白了就是一个类不通过alloc方式创建对象,而是用一个静态方法返回这个类的对象。系统只需要拥有一个的 全局对象,这样有利于我们协调系统整体的行为;<br>代理模式:代理模式给某一个对象提供一个代理对象,并由代理对象控制对源对象的引用.比如一个工厂生产了产品,并不想 直接卖给用户,而是搞了很多代理商,用户可以直接找代理商买东西,代理商从工厂进货.常见的如QQ的自动回复就属于代 理拦截,代理模式在iphone中得到广泛应用.<br>观察者模式: 当一个物体发生变化时,会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的 对象给这个物体,当这个物体的发生改变,就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的;</p>
<h3 id="25-c和obj-c如何混用"><a href="#25-c和obj-c如何混用" class="headerlink" title="25.c和obj-c如何混用?"></a>25.c和obj-c如何混用?</h3><p>1)obj-c的编译器处理后缀为m的文件时,可以识别obj-c和c的代码,处理mm文件可以识别obj-c,c,c++代码,但cpp文件必须只能用c/c++代码,而且cpp文件include的头文件中,也不能出现obj- c的代码,因为cpp只是cpp。<br>2) 在mm文件中混用cpp直接使用即可,所以obj-c混cpp不是问题<br>3)在cpp中混用obj- c其实就是使用obj-c编写的模块是我们想要的。如果模块以类实现,那么要按照cpp class的标准写类的定 义,头文件中不能出现obj-c的东西,包括#import cocoa的。 实现文件中,即类的实现代码中可以使用obj-c的东西,可以import,只是后缀是mm。如果模块以函数实现,那么头文件要按 c的格 式声明函数,实现文件中,c++函数内部可以用obj-c,但后缀还是mm或m。总结:只要cpp文件和cpp include的文件中不包含 obj-c的东西就可以用了,cpp混用obj-c的关键是使用接口,而不能直接使用实现代码,实际上cpp混用的是obj-c编译后的o文 件,这个东西其实是无差别的,所以可以用。obj-c的编译器支持cpp</p>
<h3 id="26-举出5个以上你所熟悉的ios-sdk库有哪些和第三方库有哪些"><a href="#26-举出5个以上你所熟悉的ios-sdk库有哪些和第三方库有哪些" class="headerlink" title="26.举出5个以上你所熟悉的ios sdk库有哪些和第三方库有哪些?"></a>26.举出5个以上你所熟悉的ios sdk库有哪些和第三方库有哪些?</h3><p>ios-sdk:<br>Foundation.framework,CoreGraphics.framework,UIKit.framework, MediaPlayer.framework, CoreAudio.framework<br>第三方库: 1.json编码解码MJExtension;2.ASIHTTPRequest等相关协议封装;3.MJRefresh下拉刷新代码;4.AsyncImageView 异步加载图片并缓存;5.SDWebImage——简化网络图片处理6.SVProgressHUD;7.AFNetworking</p>
<h3 id="27-UITableView的重用机制-如何在一个view上显示多个tableView-tableView要求不同的数据源以及不同的样式-要求自定义cell-如何组织各个tableView的delegate和dataSource-请说说实现思路-在一个tableView-中需要自定义多种样式的cell-两种或三种-通常你如何实现-说说思路即可-UITableView的那些元素是可以自定义的"><a href="#27-UITableView的重用机制-如何在一个view上显示多个tableView-tableView要求不同的数据源以及不同的样式-要求自定义cell-如何组织各个tableView的delegate和dataSource-请说说实现思路-在一个tableView-中需要自定义多种样式的cell-两种或三种-通常你如何实现-说说思路即可-UITableView的那些元素是可以自定义的" class="headerlink" title="27.UITableView的重用机制?如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView的delegate和dataSource?请说说实现思路?在一个tableView 中需要自定义多种样式的cell(两种或三种),通常你如何实现,说说思路即可?UITableView的那些元素是可以自定义的?"></a>27.UITableView的重用机制?如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView的delegate和dataSource?请说说实现思路?在一个tableView 中需要自定义多种样式的cell(两种或三种),通常你如何实现,说说思路即可?UITableView的那些元素是可以自定义的?</h3><p><strong>UITableView的重用机制:</strong><br>查看UITableView头文件,会找到NSMutableArray<em>visiableCells,和NSMutableArray</em>reusableTableCells两 个结构。visiableCells内保存当前显示的cells,reusableTableCells保存可重用的cells。 TableView显示之初,reusableTableCells为空,那么<br>tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都 是通过 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 来创 建,而且cellForRowAtIndexPath只是调用最大显示cell数的次数。 比如:有100条数据,iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是:</p>
<ol>
<li>用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell,并给cell指定同样的重用标识(当然,可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加 入到 visiableCells数组,reusableTableCells为空。</li>
<li>向下拖动tableView,当cell1完全移出屏幕,并且 cell11(它也是alloc出来的,原因同上)完全显示出来的时候。 cell11加入到visiableCells,cell1移出 visiableCells,cell1加入到reusableTableCells。</li>
<li>接着向下拖动tableView,因为reusableTableCells中已 经有值,所以,当需要显示新的cell, cellForRowAtIndexPath再次被调用的时 候,<br>tableView dequeueReusableCellWithIdentifier:CellIdentifier,返回cell1。 cell1加入到visiableCells,cell1 移出reusableTableCells;cell2移出 visiableCells,cell2加入到reusableTableCells。之后再需要显示的Cell就可 以正常重用了􏰂</li>
</ol>
<h3 id="28-OC中的数字对象都有哪些-简述它们与基本数据类型的区别是什么"><a href="#28-OC中的数字对象都有哪些-简述它们与基本数据类型的区别是什么" class="headerlink" title="28.OC中的数字对象都有哪些,简述它们与基本数据类型的区别是什么"></a>28.OC中的数字对象都有哪些,简述它们与基本数据类型的区别是什么</h3><p>Objective-C中的数字对象NSNumber;<br>Objective-C中的基本类型和C语言中的基本类型一样.主要有:int,long,float,double,char,void,bool等. 对于基本类型变量,不需要用指针,也不用手动回收,方法执行结束会自动回收.数字对象需要指针,也需要手动回收内存。</p>
<h3 id="29-OC中所有对象间的交互是如何实现的"><a href="#29-OC中所有对象间的交互是如何实现的" class="headerlink" title="29.OC中所有对象间的交互是如何实现的?"></a>29.OC中所有对象间的交互是如何实现的?</h3><p><strong>通过指针实现的</strong></p>
<h3 id="30-objective-c中的类型转换分为哪几类"><a href="#30-objective-c中的类型转换分为哪几类" class="headerlink" title="30.objective-c中的类型转换分为哪几类?"></a>30.objective-c中的类型转换分为哪几类?</h3><p>可变与不可变之间的转化;<br>可变与可变之间的转化;<br>不可变与不可变之间。</p>
<h3 id="31-类变量的-protected-private-public-package声明各有什么含义"><a href="#31-类变量的-protected-private-public-package声明各有什么含义" class="headerlink" title="31.类变量的@protected ,@private,@public,@package声明各有什么含义?"></a>31.类变量的@protected ,@private,@public,@package声明各有什么含义?</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">变量的作用域不同,<span class="keyword">@protected</span> 该类和所有子类中 的方法可以直接访问这样的变量,这是默认的;  </div><div class="line"><span class="keyword">@private</span> 该类中的方法可以访问这样的变量,子类不可以; <span class="keyword">@public</span>除了自己和子类方法外,也可以被其他类或者其他模块中的方法访问;  </div><div class="line"><span class="keyword">@package</span> 目前尚未得出结论</div></pre></td></tr></table></figure>
<h3 id="32-什么是序列化或者Acrchiving-可以用来做什么-怎样与copy结合-原理是什么"><a href="#32-什么是序列化或者Acrchiving-可以用来做什么-怎样与copy结合-原理是什么" class="headerlink" title="32.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?."></a>32.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.</h3><p><strong>序列化就是:归档</strong></p>
<h3 id="33-NSArray和NSMutableArray的区别-多线程操作哪个更安全"><a href="#33-NSArray和NSMutableArray的区别-多线程操作哪个更安全" class="headerlink" title="33.NSArray和NSMutableArray的区别,多线程操作哪个更安全?"></a>33.NSArray和NSMutableArray的区别,多线程操作哪个更安全?</h3><p><strong>NSArray更安全,当同时被访问时,NSArray是不可改变</strong></p>
<h3 id="34-当前有一个数组-里面有若干重复的数据-如何去除重复的数据"><a href="#34-当前有一个数组-里面有若干重复的数据-如何去除重复的数据" class="headerlink" title="34.当前有一个数组,里面有若干重复的数据,如何去除重复的数据?"></a>34.当前有一个数组,里面有若干重复的数据,如何去除重复的数据?</h3><p><strong>可以由数组,到集合</strong></p>
<h3 id="35-isKindOfClass、isMemberOfClass、selector作用分别是什么"><a href="#35-isKindOfClass、isMemberOfClass、selector作用分别是什么" class="headerlink" title="35.isKindOfClass、isMemberOfClass、selector作用分别是什么"></a>35.isKindOfClass、isMemberOfClass、selector作用分别是什么</h3><p>isKindOfClass,作用是,某个对象属于某个类型,包括继承的类型—<br>isMemberOfClass:某个对象确切属于某个类型,是不是具体的实例<br>selector:通过方法名,获取在内存中的函数的入口地址</p>
<h3 id="36-写出下面程序段的输出结果"><a href="#36-写出下面程序段的输出结果" class="headerlink" title="36.写出下面程序段的输出结果"></a>36.写出下面程序段的输出结果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@"a string value"</span> forKey:<span class="string">@"akey"</span>];  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [dict objectForKey:<span class="string">@"akey"</span>]);  </div><div class="line">[dict release];</div></pre></td></tr></table></figure>
<p><strong>打印输出 a string value,然后崩溃—-原因:便利构造器创建的对象,之后的release,会造成过度释放</strong></p>
<h3 id="37-请写出以下代码的执行结果"><a href="#37-请写出以下代码的执行结果" class="headerlink" title="37.请写出以下代码的执行结果"></a>37.请写出以下代码的执行结果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * name = [ [ <span class="built_in">NSString</span> alloc] init ];  </div><div class="line">name = @”Habb”;  </div><div class="line">[name release];</div></pre></td></tr></table></figure>
<p>打印输出结果是: Habb,在[name release]前后打印均有输出结果 —会造成内存泄露—原先指向的区域变成了野指针,之后的释放,不能释放之前创建的区域</p>
<h1 id="二、网络与多线程"><a href="#二、网络与多线程" class="headerlink" title="二、网络与多线程"></a>二、网络与多线程</h1><h3 id="1-HTTP协议详解"><a href="#1-HTTP协议详解" class="headerlink" title="1.HTTP协议详解"></a>1.HTTP协议详解</h3><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中。<br>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。<br>HTTP协议的主要特点可概括如下：<br>1.支持客户/服务器模式。<br>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。(短连接)<br>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2.URL"></a>2.URL</h3><p>HTTP URL (URL是一种特殊类型的URI是他的子类，包含了用于查找某个资源的足够的信息)的格式如下：<br><a href="http://host[&quot;:&quot;port][abs_path" target="_blank" rel="external">http://host[&quot;:&quot;port][abs_path</a>]<br>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80;<br>abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</p>
<h3 id="3-TCP-UDP区别联系"><a href="#3-TCP-UDP区别联系" class="headerlink" title="3.TCP/UDP区别联系"></a>3.TCP/UDP区别联系</h3><p>TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快 </p>
<h5 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h5><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，我们来看看这三次对话的简单过程：1.主机A向主机B发出连接请求数据包；2.主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包；3.主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。<br>tcp协议和udp协议的差别<br>是否连接面向连接面向非连接<br>传输可靠性可靠不可靠<br>应用场合传输大量数据少量数据<br>速度慢快</p>
<h3 id="4-socket连接和http连接的区别"><a href="#4-socket连接和http连接的区别" class="headerlink" title="4.socket连接和http连接的区别"></a>4.socket连接和http连接的区别</h3><p>简单说，你浏览的网页（网址以<a href="http://开头)都是http协议传输到你的浏览器的" target="_blank" rel="external">http://开头)都是http协议传输到你的浏览器的</a>, 而http是基于socket之上的。socket是一套完成tcp，udp协议的接口。<br>HTTP协议：简单对象访问协议，对应于应用层  ，HTTP协议是基于TCP连接的<br>tcp协议：    对应于传输层<br>ip协议：     对应于网络层<br>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。<br>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。<br>http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉；<br>socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息~~具体心跳消息格式是开发者自己定义的<br>我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。<br>1)Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层.<br>而http是个应用层的协议，它实际上也建立在TCP协议之上。<br>(HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。)<br>2）Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p>
<h3 id="5-什么是TCP连接的三次握手"><a href="#5-什么是TCP连接的三次握手" class="headerlink" title="5.什么是TCP连接的三次握手"></a>5.什么是TCP连接的三次握手</h3><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）</p>
<h3 id="6-利用Socket建立网络连接的步骤"><a href="#6-利用Socket建立网络连接的步骤" class="headerlink" title="6.利用Socket建立网络连接的步骤"></a>6.利用Socket建立网络连接的步骤</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>1.服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>2.客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>3.连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="7-TCP-IP通信建立的过程怎样，端口有什么作用"><a href="#7-TCP-IP通信建立的过程怎样，端口有什么作用" class="headerlink" title="7.TCP/IP通信建立的过程怎样，端口有什么作用"></a>7.TCP/IP通信建立的过程怎样，端口有什么作用</h3><p>三次握手，确定是哪个应用程序使用该协议</p>
<h3 id="8-进程和线程的差别"><a href="#8-进程和线程的差别" class="headerlink" title="8.进程和线程的差别"></a>8.进程和线程的差别</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体.(线程是进程的基本单位)<br>与进程的区别:<br>(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br>(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行<br>(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.<br>(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。  </div><div class="line">2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。  </div><div class="line">两者都可以提高程序的并发度，提高程序运行效率和响应时间。  </div><div class="line">线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。</div></pre></td></tr></table></figure></p>
<h3 id="9-简述多线程的作用以及什么地方会用到多线程-OC实现多线程的方法有哪些-谈谈多线程安全问题的几种解决方案-何为线程同步-如何实现的-分线程回调主线程方法是什么-有什么作用"><a href="#9-简述多线程的作用以及什么地方会用到多线程-OC实现多线程的方法有哪些-谈谈多线程安全问题的几种解决方案-何为线程同步-如何实现的-分线程回调主线程方法是什么-有什么作用" class="headerlink" title="9.简述多线程的作用以及什么地方会用到多线程?OC实现多线程的方法有哪些?谈谈多线程安全问题的几种解决方案?何为线程同步,如何实现的?分线程回调主线程方法是什么,有什么作用?"></a>9.简述多线程的作用以及什么地方会用到多线程?OC实现多线程的方法有哪些?谈谈多线程安全问题的几种解决方案?何为线程同步,如何实现的?分线程回调主线程方法是什么,有什么作用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(1)、多线程的作用:可以解决负载均衡问题,充分利用cpu资源 。为了提高CPU的使用率,采用多线程的方式去同时完 成几件事情而互不干扰,  </div><div class="line">(2)、大多情况下,要用到多线程的主要是需要处理大量的IO操作时或处理的情况需要花大量的时间等等,比如:读写文 件、视频图像的采集、处理、显示、保存等。   </div><div class="line">(3)、ios有三种主要方法:1、NSThread。2、NSOperation。3、GCD。  </div><div class="line">(4)解决方案:使用锁:锁是线程编程同步工具的基础。锁可以让你很容易保护代码中一大块区域以便你可以确保代码的正 确性。使用POSIX互斥锁;使用NSLock类;使用@synchronized指令等。  </div><div class="line">(5)回到主线程的方法:    </div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);作用:主线程是显示UI界面,子线程多数是进行数据处理</div></pre></td></tr></table></figure>
<h3 id="10-http和scoket通信的区别-socket连接相关库-TCP-UDP的连接方法-HTTP的几种常用方式-http和scoket通信的区别"><a href="#10-http和scoket通信的区别-socket连接相关库-TCP-UDP的连接方法-HTTP的几种常用方式-http和scoket通信的区别" class="headerlink" title="10.http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? http和scoket通信的区别"></a>10.http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? http和scoket通信的区别</h3><p>http是客户端用http协议进行请求,发送请求时候需要封装http请求头,并绑定请求的数据,服务器一般有web服务器配 合(当然也非绝对)。 http请求方式为客户端主动发起请求,服务器才能给响应,一次请求完毕后则断开连接,以节省资 源。服务器不能主动给客户端响应(除非采取http长连接技术)。iphone主要使用类是NSUrlConnection。 scoket是客户端跟服务器直接使用socket“套接字”进行连接,并没有规定连接后断开,所以客户端和服务器可以保持连 接通道,双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使 用。主要使用类是CFSocketRef。 UDP:是用户数据报协议:主要用在实时性要求高以及对质量相对较弱的地方,但面对现在高质量的线路不是容易丢包除非 是一些拥塞条件下 ,如流媒体 TCP:是传输控制协议:是面连接的,那么运行环境必然要求其可靠性不可丢包有良好的拥塞控制机制如http ftp telnet 等<br>http的常用方式:get,post</p>
<h3 id="11-你连接服务器用的是什么方法-如果请求过程中-网络出了问题这么办"><a href="#11-你连接服务器用的是什么方法-如果请求过程中-网络出了问题这么办" class="headerlink" title="11.你连接服务器用的是什么方法,如果请求过程中,网络出了问题这么办?"></a>11.你连接服务器用的是什么方法,如果请求过程中,网络出了问题这么办?</h3><p>NSUrlConnection 连接后,有一系列委托方法来接受来自服务器的响应和数据,其中接受相应的方法回得到服务器要传 回的数据有多大,接受数据的方法会反复调用来不断接受服务器数据,如果网络出了问题了,会调用一个方法让你来做相关处理。</p>
<h1 id="三、Other"><a href="#三、Other" class="headerlink" title="三、Other"></a>三、Other</h1><h3 id="1-如何将产品进行多语言发布"><a href="#1-如何将产品进行多语言发布" class="headerlink" title="1.如何将产品进行多语言发布?"></a>1.如何将产品进行多语言发布?</h3><p>程序国际化;<br>比如:本地化应用程序名称<br>(1、选中工程,Info—Localizations点击“+”添加要国际化的语言。<br>(2、在InfoPlist.strings右边会多出一个三角形,点击展开可看到InfoPlish.strings(english)和<br>InfoPlish.strings(chinese)两个版本的文件;<br>(3、在InfoPlish.strings(english)文件中加入:<br>CFBundleDisplayName =”Program”; 其中“Program”为英文应用程序名称,同理在InfoPlish.strings(chinese)文件中加入: CFBundleDisplayName =”应用程序”; 其中“应用程序”为中文名称,注意:CFBundleDisplayName加不加双引号都行;<br>(4、编辑Info.plist,添加一个新的属性Application has localized display name, 设置其类型为boolean,并将其 value设置为YES即可。</p>
<h3 id="2-什么是动态链接库和静态链接库-调用一个类的静态方法需不需要release"><a href="#2-什么是动态链接库和静态链接库-调用一个类的静态方法需不需要release" class="headerlink" title="2.什么是动态链接库和静态链接库?调用一个类的静态方法需不需要release?"></a>2.什么是动态链接库和静态链接库?调用一个类的静态方法需不需要release?</h3><p>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序,程序运行的时候不再需要其它的库文件;动态链接就是 把调用的函数所在文件模块 (DLL)和调用函数在文件中的位置等信息链接进目标程序,程序运行的时候再从DLL中寻找 相应函数代码,因此需要相应DLL文件的支持。 静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库,而在动态链接库中还 可以再包含其他的动态或静态链接库。<br>动态的是:运行时才加载到内存中,静态:编译时就加载到内存中 静态方法也就是类方法,不需要release</p>
<h3 id="3-什么是push-远程推送"><a href="#3-什么是push-远程推送" class="headerlink" title="3.什么是push?远程推送"></a>3.什么是push?远程推送</h3><p>第一步:UIApplication向APNS注册push notification服务<br>1、应用程序 要支持 推送服务(在网页里配置)<br>(1)<a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">https://developer.apple.com/devcenter/ios/index.action</a><br>(2)登录 苹果开发者账号(注意是收费账号,$99或$299)<br>(3)下载push证书(主要是给程序签名,push服务只有收费开发者才具备。所以需要签名验证),如果没有 push证书,创建一个push证书(App ID-&gt;钥匙串程序生成request-&gt;push证书)注意事项:App ID的 Bundle ID必须和程序plist文件里的Bundle identifier一致。App ID一旦生成,将不可修改。<br>(4)把证书安装到钥匙串里(双击证书文件)<br>(5)生成 编译程序 用的描述文件(网页里进行)<br>2、向APNS注册push服务(UIApplication的registerForRemoteNotificationTypes:方法)<br>第二步 获取APNS分配的DeviceToken(64位16进制串)</p>
<pre><code class="objc">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken
</code></pre>
<p>第三步 把DeviceToken发送给自己的后台服务器,服务器记录每台设备的DeviceToken以便日后推送信息给客 户端。(需要有一个网络接口,让客户端发送DeviceToken)<br>第四步 服务器推送信息给客户端<br>1、服务器除了需要有客户端的DeviceToken之外,还要有push证书,对push的内容进行签名。(苹果为了防 止 恶意向客户端(比如DeviceToken泄露了)发送消息,每次推送消息,都需要证书进行签名,从而避免黑客恶 意攻击用户手机。)<br>2、如果你的服务器是java写的,可以直接使用钥匙串导出的p12文件(证书和密钥一起导出)。如果你的服务器 是php写的,因为php语言不支持p12文件类型,需要转换为pem文件。<br>3、将p12转换为pem文件:终端 先找到你p12所在的目录 openssl pkcs12 -in CertificateName.p12 - outCertificateName.pem -nodes<br>4、服务器发送信息给APNS,APNS自动将信息推送给客户端<br>第五步 客户端处理收到的信息</p>
<pre><code class="objc">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo
</code></pre>
<p>注意事项<br>1、测试版的push证书仅仅用于开发期间测试,发布版的程序需要生成一个发布版的push证书。 2、测试版APNS的ssl地址和发布版的ssl地址不同 3、测试版的DeviceToken和发布版的DeviceToken也不同<br>4、php文件要喝pem文件放在同一目录。<br>5、除了alert sound和badge之外,json串里还可以包含自定义信息。<br>6、推送的信息最大255字节 7、推送的信息受网络影响较大,有可能造成延迟甚至丢失,重要信息的传递不应该使用push通知,应该有专门的 后台接口。<br>8、借助push推送,两个客户端可以实现即时通信,工程里面存放我们的p12文件,客户端自己组织json串,发 送请求到APNS。</p>
<h3 id="4-iphone阅读器-如果要读取一个文本文件-请问你是如何处理编码问题的-另外像pdf格式的文件-你如何读取"><a href="#4-iphone阅读器-如果要读取一个文本文件-请问你是如何处理编码问题的-另外像pdf格式的文件-你如何读取" class="headerlink" title="4.iphone阅读器,如果要读取一个文本文件,请问你是如何处理编码问题的?另外像pdf格式的文件,你如何读取?"></a>4.iphone阅读器,如果要读取一个文本文件,请问你是如何处理编码问题的?另外像pdf格式的文件,你如何读取?</h3><p>首先检测文本编码格式(只需读取小部分用来判断), iphone手机阅读器中对于PDF格式的阅读,可以直接用UIWebView控件显示,也可以从网上下到很多直接读取pdf格式 的代码<br>直接从pdf中得到数据。复杂表格动画</p>
<pre><code class="objc">- (<span class="keyword">void</span>)insertRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation:(<span class="built_in">UITableViewRowAnimation</span>)animation;
- (<span class="keyword">void</span>)deleteRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation: (<span class="built_in">UITableViewRowAnimation</span>)animation;  
- (<span class="keyword">void</span>)reloadRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation:(<span class="built_in">UITableViewRowAnimation</span>)animation;
</code></pre>
<h3 id="5-iphone-app为什么会被打回来-如何制止"><a href="#5-iphone-app为什么会被打回来-如何制止" class="headerlink" title="5.iphone app为什么会被打回来,如何制止?"></a>5.iphone app为什么会被打回来,如何制止?</h3><p>app的设置界面、按钮使用了类似iphone的操作方式以及icon的圆角设计 -&gt; 重新设计⋯<br>  app的年龄设置太低 -&gt; 改了年龄⋯<br>  app里有实物奖励 -&gt; 免责声明,和苹果无关⋯<br>  app描述里提了后续版本的功能的字样 -&gt; 删除⋯<br>  app有打分的功能 -&gt; 有reject的,也有通过的⋯<br>  app需要使用location,没有提示用户 -&gt; 加了提示,允许用户拒绝⋯<br>  app没提供测试账号 -&gt; 提供⋯<br>app里有私有api -&gt; 修改⋯ 应用内含有有某公司LOGO的图片,没有该公司授权文件,被拒-&gt; 修改⋯<br>第三方静态库包含私有api的调用(联系第三方技术支持,更新静态库); 包含潜在的色情,暴力等内容(调整应用年龄限制等级,并加入举报功能) 做浏览器的,分级必须选17+</p>
<h3 id="6-iphone应用程序的项目基本结构"><a href="#6-iphone应用程序的项目基本结构" class="headerlink" title="6.iphone应用程序的项目基本结构?"></a>6.iphone应用程序的项目基本结构?</h3><p>· Classes -&gt; 源程序文件(.h、.m)<br>· Other Sources-&gt; main.m 等,不需要程序员修改 -Prefix.pch<br>· Resources -&gt; 界面文件(.xib)、配置文件-info.plist<br>· Frameworks -&gt; 链接的库· Targets -&gt; 项目的不同Target(资源、编译配置不同)<br>· Executables -&gt; 项目中所有的可执行文件 -Prefix.pch:_Prefix为所有的项目程序文件预先配置运行环境的前缀标头,在程序运行之前,引入所需框架中的(.h)头文 件。这样可以减少每个头文件对程序编译做出相同的定义,在巨型的应用程序项目开发中节省大量的时间,例如,程序有 100个根文件需要定义abc.h,只需要在_Preix.pch文件下建立一个对象,所有的根文件便可以重复地对程序编译做出定 义。</p>
<h3 id="7-ViewController的loadView-viewDidLoad-viewWillAppear-viewDidUnload-dealloc、init分别是在什么时候调用的-在自定义ViewController的时候这几个函数里面应该做什么工作"><a href="#7-ViewController的loadView-viewDidLoad-viewWillAppear-viewDidUnload-dealloc、init分别是在什么时候调用的-在自定义ViewController的时候这几个函数里面应该做什么工作" class="headerlink" title="7.ViewController的loadView,viewDidLoad,viewWillAppear,viewDidUnload,dealloc、init分别是在什么时候调用的?在自定义ViewController的时候这几个函数里面应该做什么工作?"></a>7.ViewController的loadView,viewDidLoad,viewWillAppear,viewDidUnload,dealloc、init分别是在什么时候调用的?在自定义ViewController的时候这几个函数里面应该做什么工作?</h3><p>1、viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用<br>2、viewDidUnload当系统内存吃紧的时候会调用该方法,在该方法中将所有IBOutlet(无论是property还是实例变量) 置 为nil(系统release view时已经将其release掉了)在该方法中释放其他与view有关的对象、其他在运行时创建(但 非系统必须)的对象、在viewDidLoad中 被创建的对象、缓存数据等 release对象后,将对象置为nil(IBOutlet只需要 将其置为nil,系统release view时已经将其release掉了) dealloc方法,viewDidUnload和dealloc方法没有关联,dealloc还是继续做它该做的事情<br>流程应该是这样:<br>(loadView/nib文件)来加载view到内存 –&gt;viewDidLoad函数进一步初始化这些view –&gt;内存不足时,调用 viewDidUnload函数释放views –&gt;当需要使用view时有回到第一步<br>如此循环<br>4、viewWillAppear方法,视图即将过渡到屏幕上时调用,(一般在返回需要刷新页面时,我都选择使用代理,所以很少用到)<br>5、viewWillDisappear方法,这个A-&gt;B之后,A在B之后的操作</p>
<h3 id="8-描述程序启动的顺序"><a href="#8-描述程序启动的顺序" class="headerlink" title="8.描述程序启动的顺序"></a>8.描述程序启动的顺序</h3><p>1、main.m是程序的入口<br>2、UIApplicationMain()创建应用程序对象,并且为此对象指定委托,检测程序的执行,同时开启事件循环,处理程序接收到的事 件<br>3、UIApplicationDelegate方法的执行<br>4、加载window<br>5、指定根视图控制器 6、在指定的试图控制器中添加控件,实现应用程序界面</p>
<h3 id="9-描述下拉刷新的实现机制"><a href="#9-描述下拉刷新的实现机制" class="headerlink" title="9.描述下拉刷新的实现机制?"></a>9.描述下拉刷新的实现机制?</h3><p><strong>获取数据,刷新页面</strong></p>
<h3 id="10-简述应用程序按Home键进入后台时的生命周期-和从后台回到前台时的生命周期"><a href="#10-简述应用程序按Home键进入后台时的生命周期-和从后台回到前台时的生命周期" class="headerlink" title="10.简述应用程序按Home键进入后台时的生命周期,和从后台回到前台时的生命周期?"></a>10.简述应用程序按Home键进入后台时的生命周期,和从后台回到前台时的生命周期?</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">应用程序:  </div><div class="line">-[AppDelegate application:willFinishLaunchingWithOptions:]  </div><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:]  </div><div class="line">-[AppDelegate applicationDidBecomeActive:]   </div><div class="line">退到后台:  </div><div class="line">-[AppDelegate applicationWillResignActive:]   </div><div class="line">-[AppDelegate applicationDidEnterBackground:]   </div><div class="line">回到前台:  </div><div class="line">-[AppDelegate applicationWillEnterForeground:]   </div><div class="line">-[AppDelegate applicationDidBecomeActive:]   </div><div class="line">ViewController之间加载页面:  </div><div class="line">-[mainViewController viewDidLoad]   </div><div class="line">-[mainViewController viewWillAppear:]   </div><div class="line">-[mainViewController viewWillLayoutSubviews]   </div><div class="line">-[mainViewController viewDidLayoutSubviews]   </div><div class="line">-[mainViewController viewDidAppear:]   </div><div class="line">退出当前页面:  </div><div class="line">-[mainViewController viewWillDisappear:]  </div><div class="line">-[mainViewController viewDidDisappear:]  </div><div class="line">返回之前页面:  </div><div class="line">-[mainViewController viewWillAppear:]  </div><div class="line">-[mainViewController viewWillLayoutSubviews]  </div><div class="line">-[mainViewController viewDidLayoutSubviews]  </div><div class="line">-[mainViewController viewDidAppear:]</div></pre></td></tr></table></figure>
<h3 id="11-简述值传递和引用传递的区别"><a href="#11-简述值传递和引用传递的区别" class="headerlink" title="11.简述值传递和引用传递的区别?"></a>11.简述值传递和引用传递的区别?</h3><p>所谓值传递,就是说仅将对象的值传递给目标对象,就相当于copy;系统将为目标对象重新开辟一个完全相同的内存空间。 所谓引用传递,就是说将对象在内存中的地址传递给目标对象,就相当于使目标对象和原始对象对应同一个内存存储空间。此时,如 果对目标对象进行修改,内存中的数据也会改变。</p>
<h3 id="12-说说如何进行后台运行程序"><a href="#12-说说如何进行后台运行程序" class="headerlink" title="12.说说如何进行后台运行程序?"></a>12.说说如何进行后台运行程序?</h3><p>答:判断是否支持多线程<br>UIDevice* device = [UIDevice currentDevice];<br>BOOL backgroundSupported = NO;<br>if ([device respondsToSelector:@selector(isMultitaskingSupported)])<br>backgroundSupported = device.multitaskingSupported; 声明你需要的后台任务Info.plist中添加UIBackgroundModes键值,它包含一个或多个string的值,包括audio:在后台提供声音 播放功能,包括音频流和播放视频时的声音 location:在后台可以保持用户的位置信息 voip:在后台使用VOIP功能 前面的每个value让系统知道你的应用程序应该在适当的时候被唤醒。例如,一个应用程序,开始播放音乐,然后移动到后台仍然需要 执行时间,以填补音频输出缓冲区。添加audio键用来告诉系统框架,需要继续播放音频,并且可以在合适的时间间隔下回调应用程 序;如果应用程序不包括此项,任何音频播放在移到后台后将停止运行。除了添加键值的方法,IOS还提供了两种途径使应用程序在后 台工作:<br>Task completion—应用程序可以向系统申请额外的时间去完成给定的任务<br>Local notifications—应用程序可以预先安排时间执行local notifications 传递实现长时间的后台任务:应用程序可以请求在后台 运行以实现特殊的服务。这些应用程序并不连续的运行,但是会被系统框架在合适的时间唤醒,以实现这些服务</p>
<h3 id="13-简述你对UIView、UIWindow和CALayer的理解"><a href="#13-简述你对UIView、UIWindow和CALayer的理解" class="headerlink" title="13.简述你对UIView、UIWindow和CALayer的理解"></a>13.简述你对UIView、UIWindow和CALayer的理解</h3><p>UIView:属于UIkit.framework框架,负责渲染矩形区域的内容,为矩形区域添加动画,响应区域的触摸事件,布局和管 理一个或多个子视图 UIWindow:属于UIKit.framework框架,是一种特殊的UIView,通常在一个程序中只会有一个UIWindow,但可以手 动创建多个UIWindow,同时加到程序里面。UIWindow在程序中主要起到三个作用:<br>1、作为容器,包含app所要显示的所有视图<br>2、传递触摸消息到程序中view和其他对象<br>3、与UIViewController协同工作,方便完成设备方向旋转的支持<br>CAlayer:属于QuartzCore.framework,是用来绘制内容的,对内容进行动画处理依赖与UIView来进行显示,不能处 理用户事件。UIView和CALayer是相互依赖的,UIView依赖CALayer提供内容,CALayer依赖UIView一共容器显示 绘制内容。<br>延伸: UIViewController:管理视图的几成熟,每个视图控制器都有一个自带的视图,并且负责这个视图相关的一切事务。方便 管理视图中的子视图,负责model与view的通信;检测设备旋转以及内存警告;是所有视图控制类的积累,定义了控制器 的基本功能。<br>UIResponder的那张图</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/加密/" itemprop="url">
                  加密解密
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T11:50:50+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/19/加密/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/加密/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>加密: 是以某种特殊的算法改变原有的信息数据, 使得未授权的用户即使获得了已加密的信息, 但是因不知道解密的方法, 仍然无法了解信息的内容.</p>
<ol>
<li><p>对称加密算法</p>
<p> DES, 3DES, AES</p>
</li>
<li><p>非对称加密算法 RSA</p>
<p> <code>用公钥加密私钥解密就是加密, 用私钥加密公钥解密就是签名.</code></p>
</li>
</ol>
<h3 id="AES-3DES"><a href="#AES-3DES" class="headerlink" title="AES, 3DES"></a>AES, 3DES</h3><p>导入对应的框架的头文件 AESCrypt.h, ER3DESEncrypt.h</p>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *message = <span class="string">@"top secret message"</span>;</div><div class="line">   <span class="built_in">NSString</span> *password = <span class="string">@"p4ssw0rd"</span>;</div><div class="line">   <span class="built_in">NSString</span> *encryptedData = [AESCrypt encrypt:message password:password];</div><div class="line">   <span class="built_in">NSString</span> *decryptedData = [AESCrypt decrypt:encryptedData password:password];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"加密：%@"</span>, encryptedData);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"解密：%@"</span>, decryptedData);</div></pre></td></tr></table></figure>
<h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *message = <span class="string">@"top secret message"</span>;</div><div class="line">   <span class="built_in">NSString</span> *password = <span class="string">@"p4ssw0rd"</span>;</div><div class="line">	ER3DESEncrypt *encryptCustomKey = [[ER3DESEncrypt alloc] initWithKey:password];</div><div class="line">   <span class="built_in">NSString</span> *encryptString = [encryptCustomKey encryptString:message];</div><div class="line">   <span class="built_in">NSString</span> *decryptString = [encryptCustomKey decryptString:encryptString];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"3DES 加密:%@"</span>, encryptString);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"3DES 解密:%@"</span>, decryptString);</div></pre></td></tr></table></figure>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>导入对应的框架 <code>openssl.framework</code> 以及第三方框架 <code>JSRSA</code> 的头文件 <code>JSRSA.h</code>.</p>
<p>过程: </p>
<ol>
<li>乙方生成两把秘钥(公钥和私钥)</li>
<li>甲方获取乙方的公钥, 然后用它对信息加密</li>
<li>乙方得到加密后的信息, 用私钥解密</li>
</ol>
<p>生成密钥(终端, 指定存放的文件夹):</p>
<ol>
<li><p>生成私钥</p>
<p> openssl genrsa -out private_key.pem 512</p>
</li>
<li><p>生成公钥</p>
<p> openssl rsa -in private_key.pem -pubout -out public_key.pem</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[JSRSA sharedInstance].publicKey = <span class="string">@"public_key.pem"</span>;</div><div class="line">   [JSRSA sharedInstance].privateKey = <span class="string">@"private_key.pem"</span>;</div><div class="line">   <span class="built_in">NSString</span> *originText = <span class="string">@"hello, ios, good"</span>;</div><div class="line">   <span class="built_in">NSString</span> *plainText = [[JSRSA sharedInstance] publicEncrypt:originText];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"加密之后的密文：%@"</span>, plainText);</div><div class="line">   <span class="built_in">NSString</span> *originStr = [[JSRSA sharedInstance] privateDecrypt:plainText];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"解密之后的明文：%@"</span>, originStr);</div></pre></td></tr></table></figure>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>摘要算法 MD5</p>
<ul>
<li>MD5 将任意长度的”字符串”映射为一个128bit的大整数(通常用16进制表示为32个字符), 并且通过该128bit反推原始字符串是困难的</li>
</ul>
<p>加盐</p>
<ul>
<li>在原始密码中混入一个新的字符串, 然后再加密</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/cocoapods_常见问题/" itemprop="url">
                  CocoaPods 常见问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T11:30:06+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Cocoapods/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoapods</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/14/cocoapods_常见问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/14/cocoapods_常见问题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>新拿到一台Mac装cocoapods，老是装不上，查找网上资料最终解决了下面总结下</code></p>
<h3 id="CocoaPods的安装问题："><a href="#CocoaPods的安装问题：" class="headerlink" title="CocoaPods的安装问题："></a>CocoaPods的安装问题：</h3><ul>
<li><p>1.首先用淘宝的Ruby镜像来访问CocoaPods，打开终端输入以下命令：</p>
<p>  （1）gem sources –remove  <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a>   </p>
<p>  （2）gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>       注意：现在都是https不是http</p>
<p>  （3）gem sources -l</p>
</li>
</ul>
<p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p>
<pre><code>*** CURRENT SOURCES ***

https://ruby.taobao.org/
</code></pre><ul>
<li><p>2.升级gem，如果它的版本过低也可能导致安装失败，在终端输入以下命令：</p>
<pre><code>sudo gem update --system
</code></pre></li>
<li><p>3.安装CocoaPods:</p>
<p>  OS X 10.11以前，在终端输入以下命令：</p>
<pre><code>sudo gem install cocoapods
</code></pre><p>  OS X 10.11以后，在终端输入以下命令：</p>
<pre><code>sudo gem install -n /usr/local/bin cocoapods
</code></pre></li>
<li><p>4.setup：</p>
<p>  在终端输入以下命令：</p>
<pre><code>pod setup
</code></pre></li>
</ul>
<p>问题最多的就是这一步，第一次安装完成可能要一个小时左右，所以要耐心等待，如果这一步完成了，那么恭喜你已经成功安装了CocoaPods。想知道自己有没有安装完成，可以在终端输入以下命令：</p>
<pre><code>pod --version
</code></pre><p>显示出版本就说明成功了。</p>
<ul>
<li>5.常见问题：</li>
</ul>
<p>（1）在终端输入以下命令：</p>
<pre><code>pod repo list
</code></pre><p>结果为0 repos时说明安装不成功，自己可以查看下自己的安装步骤，看看是哪一步出现了问题。</p>
<p>（2）出现以下错误：</p>
<pre><code>ERROR:  While executing gem ... (Errno::EPERM) 
Operation not permitted - /usr/bin/xcodeproj
</code></pre><p>在网上寻找的解决方法：</p>
<pre><code>在终端中输入:

sudo nvram boot-args=&quot;rootless=0&quot;; sudo reboot
</code></pre><p>然后你的电脑会重启</p>
<pre><code>之后再输入:

sudo gem install cocoapods -V
</code></pre><p>就可以了。</p>
<p>（3）pod setup时出现以下错误：</p>
<p> 我拿到一新电脑 安装pod 常常卡在</p>
<pre><code>Setting up CocoaPods master repo 
</code></pre><p>按照网上说法:</p>
<p>使用命令 cd ~/.cocoapods/，再输入 du -sh * 查看到100M多就可以了，我发现我的问题是每次下载过程中会出现</p>
<pre><code>[!] /usr/bin/Git clone https://github.com/CocoaPods/Specs.git master

Cloning into &apos;master&apos;...

error: RPC failed; curl 56 SSLRead() return error -36

fatal: The remote end hung up unexpectedly

fatal: early EOF

fatal: index-pack failed
</code></pre><p>下次执行搜索时 还是出现这种情况<br>在网上查到的解决办法：在终端输入以下命令：</p>
<pre><code>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developers
</code></pre><p>后面的地址你可以打开Xcode显示包内容，找到那个文件夹拖到终端里面。<br>然后显示如下：</p>
<pre><code>.cocoapods ABC$ sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 

Password:

ABCdeMacBook-Pro:.cocoapods ABC$ pod search AF

Setting up CocoaPods master repo

Setup completed

Creating search index for spec repo &apos;master&apos;.. Done!

xujianfengdeMacBook-Pro:.cocoapods xujianfeng$ 
</code></pre><p>到这我的就安装成功了</p>
<ul>
<li>（4）如果还是没有安装成功：</li>
</ul>
<p>尝试：删除.cocoapods目录，在终端输入以下命令：</p>
<pre><code>cd ~/.cocoapods/

sudo -rm -rf ~/.cocoapods/
</code></pre><p>然后，重新下载安装，在终端输入以下命令：</p>
<pre><code>pod setup
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/cocoapods/" itemprop="url">
                  Cocoapods
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T11:30:06+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Cocoapods/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoapods</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/14/cocoapods/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/14/cocoapods/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h4><ul>
<li>Gem 是一个管理 Ruby 库和程序的标准包， 它通过 Ruby Gem(如：<a href="http://rubygems.org/)源来查找、安装、升级和卸载软件包" target="_blank" rel="external">http://rubygems.org/)源来查找、安装、升级和卸载软件包</a></li>
<li>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a></li>
<li>gem sources -a <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a></li>
<li>gem sources -l</li>
<li>最新源 <a href="https://gems.ruby-china.org/" target="_blank" rel="external">https://gems.ruby-china.org/</a></li>
</ul>
<h4 id="更新升级-gem-以后出现问题，-尝试这个"><a href="#更新升级-gem-以后出现问题，-尝试这个" class="headerlink" title="更新升级 gem (以后出现问题， 尝试这个)"></a>更新升级 gem (以后出现问题， 尝试这个)</h4><ul>
<li>sudo gem update –system</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>sudo gem install cocoapods</li>
</ul>
<h4 id="更换-repo-镜像为国内服务器"><a href="#更换-repo-镜像为国内服务器" class="headerlink" title="更换 repo 镜像为国内服务器"></a>更换 repo 镜像为国内服务器</h4><ul>
<li>pod repo remove master</li>
<li>pod repo add master <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a></li>
<li>pod repo add master <a href="http://git.oschina.net/akuandev/Specs.git" target="_blank" rel="external">http://git.oschina.net/akuandev/Specs.git</a></li>
</ul>
<h4 id="初始化第三方库信息-以后出现问题，-尝试这个"><a href="#初始化第三方库信息-以后出现问题，-尝试这个" class="headerlink" title="初始化第三方库信息 (以后出现问题， 尝试这个)"></a>初始化第三方库信息 (以后出现问题， 尝试这个)</h4><ul>
<li>pod setup</li>
</ul>
<h4 id="以后更新第三方库信息"><a href="#以后更新第三方库信息" class="headerlink" title="以后更新第三方库信息"></a>以后更新第三方库信息</h4><ul>
<li>pod repo update</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul>
<li>pod search</li>
</ul>
<h4 id="新建-Podfile"><a href="#新建-Podfile" class="headerlink" title="新建 Podfile"></a>新建 Podfile</h4><ul>
<li>vim Podfile</li>
<li>touch Podfile(也可以, 不会进入编辑状态)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//vim</div><div class="line">dd  //删除行, 不要进入编辑状态</div><div class="line">i //进入编辑状态</div><div class="line">platform : ios, '8.0' //平台  支持版本</div><div class="line">pod 'SDWebImage'//最新版本</div><div class="line">pod 'Masonry', '~&gt; 2.0'//指定版本</div><div class="line">esc	//退出编辑状态</div><div class="line">:wq	//保存并退出</div></pre></td></tr></table></figure>
<p><code>其他命令</code></p>
<ul>
<li>open ./     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开当前文件夹</li>
<li>cat Podfile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看文件内容</li>
</ul>
<h4 id="解析-Podfile-安装第三方框架"><a href="#解析-Podfile-安装第三方框架" class="headerlink" title="解析 Podfile, 安装第三方框架"></a>解析 Podfile, 安装第三方框架</h4><ul>
<li>pod install</li>
</ul>
<h4 id="解析第三方框架-升级第三方框架"><a href="#解析第三方框架-升级第三方框架" class="headerlink" title="解析第三方框架, 升级第三方框架"></a>解析第三方框架, 升级第三方框架</h4><ul>
<li>pod update</li>
</ul>
<h4 id="使用-CocoaPods-过程中出现问题"><a href="#使用-CocoaPods-过程中出现问题" class="headerlink" title="使用 CocoaPods 过程中出现问题"></a>使用 CocoaPods 过程中出现问题</h4><ul>
<li>sudo gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>pod setup</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/UITextField整理/" itemprop="url">
                  UITextField
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T16:20:33+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/UITextField整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/UITextField整理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、UITextField属性"><a href="#一、UITextField属性" class="headerlink" title="一、UITextField属性"></a>一、UITextField属性</h1><p>设置和获取文字框文字</p>
<pre><code>@property(nonatomic,copy) NSString *text;
</code></pre><p>通过AttributedString创建和获取文字</p>
<pre><code>@property(nonatomic,copy) NSAttributedString *attributedText；
</code></pre><p>设置字体颜色属性</p>
<pre><code>@property(nonatomic,retain) UIColor *textColor;
</code></pre><p>设置字体属性</p>
<pre><code>@property(nonatomic,retain) UIFont *font
</code></pre><p>设置字体对齐格式</p>
<pre><code>@property(nonatomic)NSTextAlignment textAlignment;
</code></pre><p>设置输入框风格</p>
<pre><code>@property(nonatomic) UITextBorderStyle borderStyle;

UITextBorderStyleNone,            //没有任何边框
UITextBorderStyleLine,            //线性边框
UITextBorderStyleBezel,            //阴影效果边框
UITextBorderStyleRoundedRect    //原型效果边框
</code></pre><p>设置默认字体属性</p>
<pre><code>@property(nonatomic,copy) NSDictionary *defaultTextAttributes；
</code></pre><p><strong>注：这个属性的设置会影响到全部字体的属性。</strong><br>设置占位图片</p>
<pre><code>@property(nonatomic,copy) NSString *placeholder;
@property(nonatomic,copy) NSAttributedString *attributedPlaceholder；
</code></pre><p>设置是否在开始编辑时清空输入框内容</p>
<pre><code>@property(nonatomic) BOOL clearsOnBeginEditing;
</code></pre><p>设置字体大小是否随宽度自适应（默认为NO）</p>
<pre><code>@property(nonatomic) BOOL adjustsFontSizeToFitWidth;
</code></pre><p>设置最小字体大小</p>
<pre><code>@property(nonatomic) CGFloat minimumFontSize
</code></pre><p>设置背景图片（会被拉伸）</p>
<pre><code>@property(nonatomic,retain) UIImage *background;
@property(nonatomic,retain) UIImage *disabledBackground;
</code></pre><p>设置清除按钮的显示模式</p>
<pre><code>@property(nonatomic) UITextFieldViewMode clearButtonMode;

UITextFieldViewModeNever,            //从不显示
UITextFieldViewModeWhileEditing,    //编辑的时候显示
UITextFieldViewModeUnlessEditing,    //非编辑的时候显示
UITextFieldViewModeAlways            //任何时候都显示
</code></pre><p>设置输入框左/右边的view</p>
<pre><code>@property(nonatomic,retain) UIView *leftView;
@property(nonatomic,retain) UIView *rightView;
</code></pre><p>设置输入框左/右视图的显示模式</p>
<pre><code>@property(nonatomic) UITextFieldViewMode leftViewMode;
@property(nonatomic) UITextFieldViewMode rightViewMode;
</code></pre><p>设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘）</p>
<pre><code>@property (readwrite, retain) UIView *inputView;
@property (readwrite, retain) UIView *inputAccessoryView;
</code></pre><p>这个属性设置是否允许再次编辑时在内容中间插入内容</p>
<pre><code>@property(nonatomic) BOOL clearsOnInsertion；
</code></pre><p>密码文本框是暗文(UITextInputTraits) </p>
<pre><code>@property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;       
</code></pre><h3 id="补充三个不常用方法（UIKeyInput）"><a href="#补充三个不常用方法（UIKeyInput）" class="headerlink" title="补充三个不常用方法（UIKeyInput）"></a>补充三个不常用方法（UIKeyInput）</h3><p>判断UITextField当前是否有内容</p>
<pre><code>- (BOOL)hasText;
</code></pre><p>从键盘输入内容就会调用此方法（中文无效）</p>
<pre><code>- (void)insertText:(NSString *)text;
</code></pre><p>当击UITextField右边大删除按钮</p>
<pre><code>- (void)deleteBackward;
</code></pre><h1 id="二、UITextField-设置监听的3种方式"><a href="#二、UITextField-设置监听的3种方式" class="headerlink" title="二、UITextField 设置监听的3种方式:"></a>二、UITextField 设置监听的3种方式:</h1><h3 id="1、通过addTarget方式"><a href="#1、通过addTarget方式" class="headerlink" title="1、通过addTarget方式"></a>1、通过addTarget方式</h3><ul>
<li>UITextField继承UIControll,可以addTarget监听。</li>
<li>但是这种方式只能监听一些”单击事件”、”滚动条滚动事件”等, 有些事件通过addTarget方式监听无效, 比如”Value Changed”事件。</li>
</ul>
<h3 id="2、通过代理"><a href="#2、通过代理" class="headerlink" title="2、通过代理"></a>2、通过代理</h3><ul>
<li>文本框的代理协议”UITextFieldDelegate”。</li>
<li>演示:textFieldShouldBeginEditing方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 为某个文本框设置代理</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // 设置文本框代理为当前控制器。</div><div class="line">    self.textFidld.delegate = self;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">// 让当前控制器遵守UITextFieldDelegate协议, 并且实现- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField方法, 返回YES</div><div class="line">- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField</div><div class="line">&#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、通过”通知中心”监听事件。"><a href="#3、通过”通知中心”监听事件。" class="headerlink" title="3、通过”通知中心”监听事件。"></a>3、通过”通知中心”监听事件。</h3><p><strong> 思路: 让用户名、密码文本框同时设置监听到textChanged方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//参考代码:</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">//通过通知中心监听文本框内容变化, 添加观察者</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldValueChanged) name:UITextFieldTextDidChangeNotification object:self.userNameTextField];</div><div class="line"></div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldValueChanged) name:UITextFieldTextDidChangeNotification object:self.passWordTextField];</div><div class="line"></div><div class="line">//TextField通知名</div><div class="line">//    UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;</div><div class="line">//    UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;</div><div class="line">//    UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实现监听方法</div><div class="line">- (void) textFieldValueChanged</div><div class="line">&#123;</div><div class="line">    //文本框的值发送改变, 就会调用</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**** 注意通过通知的方式注册事件, 需要在dealloc方法中移除 ****/</div><div class="line">// 移除通知监听, 观察者被销毁时, 在观察着的dealloc方法中移除</div><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">    //移除观察者</div><div class="line">    [[NSNotificationCenter defaultCenter]removeObserver:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、Segue对象。"><a href="#4、Segue对象。" class="headerlink" title="4、Segue对象。"></a>4、Segue对象。</h3><ul>
<li><p>在xcode6.1下, 拖线时选择Segue的style为show, 等价于以前的push。</p>
</li>
<li><p>重新拖线（手动 Segue）, 从控制器 to 控制器。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//参考代码 :</div><div class="line">[self performSegueWithIdentifier:@&quot;login2contact&quot; sender:@&quot;Jack&quot;];</div><div class="line"></div><div class="line">//实现控制器的- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender方法。</div><div class="line"></div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">// Get the new view controller using [segue destinationViewController].</div><div class="line">// Pass the selected object to the new view controller.</div><div class="line">//    NSLog(@&quot;%@&quot;,sender);</div><div class="line">//获取目标控制器</div><div class="line">    UIViewController * targetVC = segue.destinationViewController;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//performSegueWithIdentifier:sender:的执行过程</div><div class="line">[self performSegueWithIdentifier:@&quot;login2contacts&quot; sender:nil];</div><div class="line">//1&gt; self是来源控制器，只能通过来源控制器来调该方法。</div><div class="line">//2&gt; 根据identifier去storyboard中找到对应的线，新建UIStoryboardSegue对象</div><div class="line">//3&gt; 设置Segue对象的sourceViewController（来源控制器）</div><div class="line">//4&gt; 新建并且设置Segue对象的destinationViewController（目标控制器）</div><div class="line">//5&gt; 调用- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender方法</div><div class="line">//6&gt; 执行跳转。</div><div class="line">//** 具体跳转步骤:</div><div class="line">//1&gt; 通过segue对象的sourceViewController获取源控制器所在的导航控制器。</div><div class="line">//2&gt; 将segue的destinationViewControlelr压栈(push)进去。</div></pre></td></tr></table></figure>
<h3 id="5、提示框的弹出"><a href="#5、提示框的弹出" class="headerlink" title="5、提示框的弹出"></a>5、提示框的弹出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//xcode7下</div><div class="line">- (IBAction)logOutBtnClick:(id)sender</div><div class="line">&#123;</div><div class="line">    UIAlertController * alert = [UIAlertController alertControllerWithTitle:@&quot;确定注销吗?&quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];</div><div class="line"></div><div class="line">    UIAlertAction * okAction = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) &#123;</div><div class="line">    [self.navigationController popViewControllerAnimated:YES];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    UIAlertAction * cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];</div><div class="line"></div><div class="line">    [alert addAction:okAction];</div><div class="line"></div><div class="line">    [alert addAction:cancel];</div><div class="line"></div><div class="line">    [self presentViewController:alert animated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// xcode6</div><div class="line"></div><div class="line">// 1. 弹出UIActionSheet对话框</div><div class="line">UIActionSheet *sheet = [[UIActionSheet alloc] initWithTitle:@&quot;确定要注销&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:@&quot;注销&quot; otherButtonTitles:nil, nil];</div><div class="line"></div><div class="line">//alertView 上添加一个 textField</div><div class="line">/*</div><div class="line">UIAlertViewStyleDefault = 0,</div><div class="line">UIAlertViewStyleSecureTextInput,//安全的文本输入, 密码保护模式</div><div class="line">UIAlertViewStylePlainTextInput,//普通的文本输入</div><div class="line">UIAlertViewStyleLoginAndPasswordInput//两行输入,Login 和 Password</div><div class="line">*/</div><div class="line">alertView.alertViewStyle = UIAlertViewStylePlainTextInput;</div><div class="line"></div><div class="line">//获取 alertView上的 textField</div><div class="line">UITextField *textField = [alertView textFieldAtIndex:0];</div><div class="line"></div><div class="line">[sheet showInView:self.view];</div></pre></td></tr></table></figure>
<ul>
<li>UIActionSheet中的按钮点击事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex</div><div class="line">&#123;</div><div class="line">    //buttonIndex 对应按钮的下标</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="awakeFromNib"><a href="#awakeFromNib" class="headerlink" title="awakeFromNib"></a>awakeFromNib</h3><ul>
<li>awakeFromNib什么时候调用？xib加载完成的时候调用</li>
<li>awakeFromNib的作用:从控件从xib加载完成之后，做一些初始化操作。</li>
<li>在layoutSubViews设置尺寸。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/struct/" itemprop="url">
                  Struct结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:39:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/struct/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/struct/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、【理解】NSPoint和CGPoint的使用"><a href="#1、【理解】NSPoint和CGPoint的使用" class="headerlink" title="1、【理解】NSPoint和CGPoint的使用"></a>1、【理解】NSPoint和CGPoint的使用</h4><ul>
<li>CGPoint和NSPoint是同义的</li>
<li><code>typedef CGPoint NSPoint;</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGPoint</span>的定义</div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGPoint</span> &#123;</div><div class="line">  <span class="built_in">CGFloat</span> x;</div><div class="line">  <span class="built_in">CGFloat</span> y;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGPoint</span> <span class="built_in">CGPoint</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="built_in">CGFloat</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>CGPoint代表的是二维平面中的一个点,可以使用CGPointMake和NSMakePoint函数创建CGPoint.</code></p>
<h4 id="2、【理解】NSSize和CGSize的使用"><a href="#2、【理解】NSSize和CGSize的使用" class="headerlink" title="2、【理解】NSSize和CGSize的使用"></a>2、【理解】NSSize和CGSize的使用</h4><ul>
<li>CGSize和NSSize是同义的</li>
<li><code>typedef CGSize NSSize;</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGSize</span>的定义</div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGSize</span> &#123;</div><div class="line">  <span class="built_in">CGFloat</span> width;</div><div class="line">  <span class="built_in">CGFloat</span> height;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGSize</span> <span class="built_in">CGSize</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>CGSize代表的是二维平面中的某个物体的尺寸(宽度和高度)
可以使用CGSizeMake和NSMakeSize函数创建CGSize</code></p>
<h4 id="3、【理解】NSRect和CGRect的使用"><a href="#3、【理解】NSRect和CGRect的使用" class="headerlink" title="3、【理解】NSRect和CGRect的使用"></a>3、【理解】NSRect和CGRect的使用</h4><ul>
<li>CGRect和NSRect是同义的</li>
<li><code>typedef CGRect NSRect;</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span>的定义</div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</div><div class="line">  <span class="built_in">CGPoint</span> origin;</div><div class="line">  <span class="built_in">CGSize</span> size;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGRect</span> <span class="built_in">CGRect</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>CGRect代表的是二维平面中的某个物体的位置和尺寸
可以使用CGRectMake和NSMakeRect函数创建CGRect</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/singletonpattern/" itemprop="url">
                  单例模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:39:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/singletonpattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/singletonpattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、单例模式概念"><a href="#1、单例模式概念" class="headerlink" title="1、单例模式概念"></a>1、单例模式概念</h4><ul>
<li><p>1、 什么是单例模式:(Singleton)</p>
<ul>
<li>单例模式的意图是的类的对象成为系统中唯一的实例,提供一个访问点,供客户类共享资源。</li>
</ul>
</li>
<li><p>2、 什么情况下使用单例?</p>
<ul>
<li>1）类只能有一个实例,而且必须从一个为人熟知的访问点对其进行访问,比如工厂方法。</li>
<li>2）这个唯一的实例只能通过子类化进行扩展,而且扩展的对象不会破坏客户端代码。</li>
</ul>
</li>
<li><p>3、 单例设计模式的要点:</p>
<ul>
<li>1）某个类只能有一个实例。</li>
<li>2）他必须自行创建这个对象</li>
<li>3）必须自行向整个系统提供这个实例;</li>
<li><p>4）为了保证实例的唯一性,我们必须将如下方法实现进行覆盖</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone +(<span class="keyword">id</span>)allocWithZone:(<span class="built_in">NSZone</span> *)zone -(<span class="keyword">id</span>)<span class="keyword">retain</span> -(<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release</div><div class="line">-(<span class="keyword">id</span>)autorelease 。</div></pre></td></tr></table></figure>
</li>
<li><p>5）这个方法必须是一个静态类。</p>
</li>
</ul>
</li>
<li>4、 在OC中实现单例模式:<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">先创建一个单例类,即:</div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bee</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;//注意此处调用了<span class="title">NScoping</span>协议</span></div><div class="line">+ (Bee *)shareIsrance;<span class="comment">//此处定义了一个工厂方法,用工厂方法来限制实例化过程</span></div><div class="line"><span class="keyword">@end</span> <span class="comment">//调用NScoping协议,从而在实现文件中覆盖</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="简单的单例模式实现"><a href="#简单的单例模式实现" class="headerlink" title="简单的单例模式实现"></a>简单的单例模式实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Tools.h文件</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tools</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></div><div class="line"><span class="comment">//一般情况下,创建一个单例对象都会提供一个类工厂方法</span></div><div class="line"><span class="comment">//一般情况下,用于创建单例对象的方法名都以 share 开头或 default 开头</span></div><div class="line"><span class="comment">// share + 当前的类名</span></div><div class="line">+ (<span class="keyword">instancetype</span>)shareTools;<span class="comment">//仅仅是提供一个 share 的类方法,无其他意义</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Tools.m文件</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Tools.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tools</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)shareTools</div><div class="line">&#123;</div><div class="line">    Tools *instance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="keyword">return</span> instance;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> Tools *_instance = <span class="literal">nil</span>;<span class="comment">//1.定义一个全局变量</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</div><div class="line">&#123;</div><div class="line"><span class="comment">//    多线程可能有问题</span></div><div class="line"><span class="comment">//    2.由于所有的创建方法都会调用该方法,所以只需要在该方法中控制当前对象只创建一次</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    if (_instance == nil) &#123;</div><div class="line">        _instance = [[super allocWithZone:zone] init];</div><div class="line">    &#125;</div><div class="line">    return _instance;</div><div class="line">     */</div><div class="line"><span class="comment">//    以下在多线程也没有问题 保证在多线程也执行一次  GCD</span></div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instance = [[<span class="keyword">super</span> allocWithZone:zone] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"><span class="comment">//  3.重写 copy</span></div><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MRC 中的单例要重写以下方法</span></div><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line"><span class="comment">//    为了保证整个程序过程中只有一份实例,在这个方法中什么都不做</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line"><span class="comment">//    return 1;</span></div><div class="line"><span class="comment">//    注意:为了方便沟通,一般情况下,单例中不会返回 retainCount = 1;</span></div><div class="line"><span class="comment">//    一般返回比较大的值</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSUIntegerMax</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/setmemorymanagement/" itemprop="url">
                  set方法的内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:39:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/setmemorymanagement/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/setmemorymanagement/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>需求：<ul>
<li>1、让玩家换房间，进入1号房间后，再进入2号房间</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现玩家类</span></div><div class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">Gamer</span></span></div><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room</div><div class="line">&#123;</div><div class="line">    [_room release];</div><div class="line">    _room = [room <span class="keyword">retain</span>];</div><div class="line">&#125;</div><div class="line">- (Room *)room&#123;</div><div class="line">    <span class="keyword">return</span> _room;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [_room dealloc];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"玩家被释放"</span>);</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">    <span class="comment">// 1、创建玩家对象</span></div><div class="line">    Gamer *game = [[Gamer alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2、创建房间对象</span></div><div class="line">    Room *room = [[Room alloc] init];</div><div class="line">    room.no = <span class="number">1</span>;</div><div class="line"></div><div class="line">    Room *room1 = [[room alloc] init];</div><div class="line">    room.no = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3、让玩家进入房间</span></div><div class="line">    game.room = room;</div><div class="line">    game.room = room1;</div><div class="line"></div><div class="line">    <span class="comment">// 4、释放房间对象</span></div><div class="line">    [room release];</div><div class="line"></div><div class="line">    <span class="comment">// 5、释放玩家对象</span></div><div class="line">    [game release];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>问题：房间对象再次无法被释放</li>
<li>解决方案：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_room != room) &#123;</div><div class="line">        <span class="comment">// 释放旧房间</span></div><div class="line">        [_room release];</div><div class="line">        [room <span class="keyword">retain</span>];</div><div class="line">        _room = room;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>总结：</li>
<li>1、set方法的内存管理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_room != room) &#123;</div><div class="line">    [_room release];</div><div class="line">    _room = [room <span class="keyword">retain</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2、dealloc方法内存管理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 当玩家不在了，代表不用房间了</span></div><div class="line">    <span class="comment">// 对房间进行一次release</span></div><div class="line">    [_room release];</div><div class="line"></div><div class="line">    <span class="comment">// 重写dealloc方法，必须在最后调用父类的dealloc方法</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>常见错误写法</li>
<li>会引发内存泄露<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gamer.room = [[Room alloc] init];</div><div class="line">[[Room alloc] init].no= <span class="number">10</span>;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/property/" itemprop="url">
                  property
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T11:39:06+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/07/property/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/07/property/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>@property 4.4前</p>
<ul>
<li>1) @property + 手动实现</li>
<li>2) @property int age; + @synthesize age;//get和set方法的声明和实现都帮我们做了</li>
<li>3) @property int age + @synthesizes age = _b;</li>
</ul>
</li>
<li><p>@property 4.4增强 .h</p>
</li>
<li>@property int age;<ul>
<li>1) 生成_age</li>
<li>2) 生成_age的get和set方法的声明</li>
<li>3) 实现_age的get和set方法</li>
</ul>
</li>
</ul>
<h4 id="property-参数-一"><a href="#property-参数-一" class="headerlink" title="@property 参数(一)"></a>@property 参数(一)</h4><ul>
<li>格式:@property (参数1,参数2) 数据类型 方法名<br><img src="/img/10.1.png" alt=""></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基本数据类型</span></div><div class="line"><span class="keyword">int</span> _age;</div><div class="line"></div><div class="line"><span class="comment">// set方法的写法</span></div><div class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>) age</div><div class="line">&#123;</div><div class="line">_age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用assign修饰后，仍旧会生成以上标准的set方法</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">int</span> age;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// oc对象类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>) Car *car ;</div><div class="line"></div><div class="line"><span class="comment">// 用retain修饰后，生成如下内存管理代码</span></div><div class="line">-(<span class="keyword">void</span>)setCar:(<span class="keyword">int</span>) car</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(_car ! = car)</div><div class="line">   &#123;</div><div class="line">      [_car release];</div><div class="line">      _car = [car <span class="keyword">retain</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.内存管理相关参数<ul>
<li>retain ： release旧值，retain新值（用于OC对象）</li>
<li>assign ： 直接赋值，不做任何内存管理(默认，用于非OC对象类型)</li>
<li>copy   ： release旧值，copy新值（一般用于NSString *）</li>
</ul>
</li>
</ul>
<ul>
<li>验证assign如果作用在对象上,实际上就是直接赋值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用@property增强型 生成get和set方法</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)Car *car;</div><div class="line"></div><div class="line"><span class="comment">//.m文件中实际上生成的是</span></div><div class="line">- (<span class="keyword">void</span>)setCar:(Car *)cat</div><div class="line">&#123;</div><div class="line">   _car = car; <span class="comment">//当对象release后,将无法使用该对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line"> Person *p = [Person new];</div><div class="line"> Car *c = [Car new];</div><div class="line"></div><div class="line"> <span class="comment">// 给人一辆车</span></div><div class="line"> p.car = c;</div><div class="line"></div><div class="line"> <span class="comment">// 释放车</span></div><div class="line"> [c release];</div><div class="line"></div><div class="line"> <span class="comment">// 让人开车</span></div><div class="line"> [p drive]; <span class="comment">//此时p指向了僵尸对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用@property增强型 生成get和set方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用@property增强型 生成get和set方法</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>)Car *car;</div><div class="line"></div><div class="line"><span class="comment">//.m文件中实际上生成的是</span></div><div class="line">- (<span class="keyword">void</span>)setCar:(Car *)cat</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(_car != car)</div><div class="line">   &#123;</div><div class="line">     [_car release];</div><div class="line">     _car = [car <span class="keyword">retain</span>];</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line"> Person *p = [Person new];</div><div class="line"> Car *c = [Car new];</div><div class="line"></div><div class="line"> <span class="comment">// 给人一辆车</span></div><div class="line"> p.car = c;</div><div class="line"></div><div class="line"> <span class="comment">// 释放车</span></div><div class="line"> [c release];</div><div class="line"></div><div class="line"> <span class="comment">// 让人开车</span></div><div class="line"> [p drive];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>此时，会发生内存泄露。</li>
<li>解决办法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person -- dealloc"</span>);</div><div class="line">    [_car release];</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="property-参数-二"><a href="#property-参数-二" class="headerlink" title="@property 参数(二)"></a>@property 参数(二)</h4><ul>
<li><p>1、是否要生成set方法(若为只读属性,则不生成)</p>
<ul>
<li>readonly:只读,只会生成get的声明和实现</li>
<li>readwrite:默认的,同时生成set和get的声明和实现</li>
</ul>
</li>
<li><p>2.多线程管理(苹果在一定程度上屏蔽了多线程操作)</p>
<ul>
<li>nonatomic:高性能,一般使用这个</li>
<li><p>atomic:低性能,默认</p>
</li>
<li><p>atomic是Objc使用的一种线程保护技术,基本上来讲,是防止在写未完成的时候被另外一个线程读取,造成数据错误。而这种机制是耗费系统资源的,所以在iPhone这种小型设备上,如果没有使用多线程间的通讯编程,那么nonatomic是一个非常好的选择。</p>
</li>
</ul>
</li>
<li><p>3.set和get方法的名称</p>
<ul>
<li><p>修改set和get方法的名称,主要用于布尔类型。因为返回布尔类型的方法名一般以is开头,修改 名称一般用在布尔类型中的getter。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">控制set方法和get方法的名称</div><div class="line"><span class="keyword">setter</span> ： 设置set方法的名称，一定有个冒号:</div><div class="line"><span class="keyword">getter</span> ： 设置get方法的名称</div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>, <span class="keyword">setter</span>=abc:,<span class="keyword">getter</span>=haha)<span class="keyword">int</span> age</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以理解为：</p>
<ul>
<li>[p setAge: ]——&gt; [p abc:],</li>
<li>[p age] ———&gt; [p haha];</li>
<li>p.age 不会报错(内部优化)</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>, <span class="keyword">setter</span>=setVip:,<span class="keyword">getter</span>=isVip) <span class="built_in">BOOL</span> vip;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=697890588,3646918970&fm=116&gp=0.jpg"
               alt="℡颜文字♡" />
          <p class="site-author-name" itemprop="name">℡颜文字♡</p>
          <p class="site-description motion-element" itemprop="description">颜貌岁岁改，波澜誓不起。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">103</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanhuangzisuen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/yanyan767006743" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">℡颜文字♡</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yancode"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
